#!/bin/bash
#
# Polis - Decentralized Social Network CLI
#
# Dependencies:
#   - ssh-keygen (OpenSSH 8.0+ for Ed25519 signing with -Y flag)
#   - jq (JSON processor for index management and JSON mode)
#   - curl (for API communication with discovery service)
#   - sha256sum or shasum (for content hashing)
#   - git (optional, for version control integration)
#   - pandoc (optional, for render command - markdown to HTML conversion)
#   - Standard Unix tools: date, sed, grep, mktemp, realpath/readlink
#
# Installation:
#   Linux:   sudo apt-get install openssh-client jq curl coreutils git pandoc
#   macOS:   brew install openssh jq curl coreutils git pandoc
#

set -e

# ============================================================================
# CONFIGURATION LOADING
# ============================================================================
# Precedence (highest to lowest):
#   1. Environment variables
#   2. .env file
#   3. .well-known/polis config section
#   4. Hardcoded defaults

# Fixed constants (never configurable - required for discovery)
VERSION="0.18.0"
WELL_KNOWN_DIR=".well-known"
WELL_KNOWN_FILE="polis"

# Load .env file with validation (does not override existing env vars)
load_env_file() {
    local env_file="${1:-.env}"
    [ ! -f "$env_file" ] && return 0

    while IFS='=' read -r key value || [ -n "$key" ]; do
        # Skip comments, empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        # Trim whitespace from key
        key="${key#"${key%%[![:space:]]*}"}"
        key="${key%"${key##*[![:space:]]}"}"

        # Skip if key is empty or contains invalid characters
        [[ ! "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]] && continue

        # Trim whitespace and quotes from value
        value="${value#"${value%%[![:space:]]*}"}"
        value="${value%"${value##*[![:space:]]}"}"
        value="${value%\"}"
        value="${value#\"}"
        value="${value%\'}"
        value="${value#\'}"

        # Only set if not already defined in environment
        if [ -z "${!key+x}" ]; then
            export "$key=$value"
        fi
    done < "$env_file"
}

# Load user config from .well-known/polis JSON
load_wellknown_config() {
    local config_file="$WELL_KNOWN_DIR/$WELL_KNOWN_FILE"
    [ ! -f "$config_file" ] && return 0

    # Check if jq is available
    command -v jq > /dev/null 2>&1 || return 0

    # Extract config values (only if not already set)
    local config_json
    config_json=$(jq -r '.config // empty' "$config_file" 2>/dev/null) || return 0
    [ -z "$config_json" ] && return 0

    # Directory config
    [ -z "${KEYS_DIR+x}" ] && KEYS_DIR=$(echo "$config_json" | jq -r '.directories.keys // empty')
    [ -z "${POSTS_DIR+x}" ] && POSTS_DIR=$(echo "$config_json" | jq -r '.directories.posts // empty')
    [ -z "${COMMENTS_DIR+x}" ] && COMMENTS_DIR=$(echo "$config_json" | jq -r '.directories.comments // empty')
    [ -z "${VERSIONS_DIR_NAME+x}" ] && VERSIONS_DIR_NAME=$(echo "$config_json" | jq -r '.directories.versions // empty')

    # File config
    [ -z "${PUBLIC_INDEX+x}" ] && PUBLIC_INDEX=$(echo "$config_json" | jq -r '.files.public_index // empty')
    [ -z "${BLESSED_COMMENTS+x}" ] && BLESSED_COMMENTS=$(echo "$config_json" | jq -r '.files.blessed_comments // empty')
    [ -z "${FOLLOWING_INDEX+x}" ] && FOLLOWING_INDEX=$(echo "$config_json" | jq -r '.files.following_index // empty')
}

# Apply hardcoded defaults for any unset variables
apply_defaults() {
    # Developer config defaults
    : "${POLIS_BASE_URL:=}"
    : "${POLIS_ENDPOINT_BASE:=https://ltfpezriiaqvjupxbttw.supabase.co/functions/v1}"
    : "${DISCOVERY_SERVICE_KEY:=}"

    # Derived endpoints (always computed from base)
    POLIS_BESEECH_ENDPOINT="${POLIS_ENDPOINT_BASE}/comments-blessing-beseech"
    POLIS_BLESSING_REQUESTS_ENDPOINT="${POLIS_ENDPOINT_BASE}/comments-blessing-requests"
    POLIS_BLESS_ENDPOINT="${POLIS_ENDPOINT_BASE}/comments-blessing-grant"
    POLIS_DENY_ENDPOINT="${POLIS_ENDPOINT_BASE}/comments-blessing-deny"
    POLIS_COMMENTS_ENDPOINT="${POLIS_ENDPOINT_BASE}/comments"

    # User directory defaults
    : "${KEYS_DIR:=.polis/keys}"
    : "${POSTS_DIR:=posts}"
    : "${COMMENTS_DIR:=comments}"
    : "${VERSIONS_DIR_NAME:=.versions}"

    # User file defaults
    : "${PUBLIC_INDEX:=metadata/public.jsonl}"
    : "${BLESSED_COMMENTS:=metadata/blessed-comments.json}"
    : "${FOLLOWING_INDEX:=metadata/following.json}"
}

# Main configuration initialization
init_config() {
    load_env_file ".env"
    load_wellknown_config
    apply_defaults
}

# Initialize configuration immediately
init_config

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
DIM='\033[2m'
NC='\033[0m' # No Color

# JSON output mode flag
JSON_MODE=false

# Helper function for colored output
info() {
    echo -e "${BLUE}[i]${NC} $1"
}

success() {
    echo -e "${GREEN}[âœ“]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[!]${NC} $1" >&2
}

error() {
    echo -e "${RED}[x]${NC} $1" >&2
    exit 1
}

# JSON-aware output helpers
json_success() {
    local command="$1"
    local data="$2"

    if [ "$JSON_MODE" = true ]; then
        jq -n \
            --arg cmd "$command" \
            --argjson data "$data" \
            '{status: "success", command: $cmd, data: $data}'
    fi
}

json_error() {
    local command="$1"
    local code="$2"
    local message="$3"
    local details="${4:-{}}"

    if [ "$JSON_MODE" = true ]; then
        jq -n \
            --arg cmd "$command" \
            --arg code "$code" \
            --arg msg "$message" \
            --argjson details "$details" \
            '{status: "error", command: $cmd, error: {code: $code, message: $msg, details: $details}}' >&2
    else
        error "$message"
    fi
    exit 1
}

# Conditional output - only shows in human mode
info_human() {
    if [ "$JSON_MODE" = false ]; then
        info "$1"
    fi
}

success_human() {
    if [ "$JSON_MODE" = false ]; then
        success "$1"
    fi
}

warn_human() {
    if [ "$JSON_MODE" = false ]; then
        warn "$1"
    fi
}

# Print to stderr in JSON mode (for showing defaults)
log_default() {
    if [ "$JSON_MODE" = true ]; then
        echo "[default] $1" >&2
    fi
}

# Command: polis init
cmd_init() {
    # Parse optional arguments for custom paths
    local custom_keys_dir=""
    local custom_posts_dir=""
    local custom_comments_dir=""
    local custom_public_index=""
    local custom_blessed_comments=""
    local custom_following_index=""
    local custom_versions_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keys-dir)
                custom_keys_dir="$2"
                shift 2
                ;;
            --posts-dir)
                custom_posts_dir="$2"
                shift 2
                ;;
            --comments-dir)
                custom_comments_dir="$2"
                shift 2
                ;;
            --public-index)
                custom_public_index="$2"
                shift 2
                ;;
            --blessed-comments)
                custom_blessed_comments="$2"
                shift 2
                ;;
            --following-index)
                custom_following_index="$2"
                shift 2
                ;;
            --versions-dir)
                custom_versions_dir="$2"
                shift 2
                ;;
            *)
                error "Unknown option: $1. Use 'polis help init' for usage."
                ;;
        esac
    done

    # Apply custom paths (override defaults for this init)
    local keys_dir="${custom_keys_dir:-$KEYS_DIR}"
    local posts_dir="${custom_posts_dir:-$POSTS_DIR}"
    local comments_dir="${custom_comments_dir:-$COMMENTS_DIR}"
    local public_index="${custom_public_index:-$PUBLIC_INDEX}"
    local blessed_comments="${custom_blessed_comments:-$BLESSED_COMMENTS}"
    local following_index="${custom_following_index:-$FOLLOWING_INDEX}"
    local versions_dir="${custom_versions_dir:-$VERSIONS_DIR_NAME}"

    # Derive metadata directory from file paths
    local metadata_dir=$(dirname "$public_index")

    info_human "Initializing Polis directory structure..."

    # Track created items for JSON output
    local dirs_created=()
    local files_created=()

    # Create directory structure
    mkdir -p "$keys_dir"
    mkdir -p "$posts_dir"
    mkdir -p "$comments_dir"
    mkdir -p "$metadata_dir"
    mkdir -p "$WELL_KNOWN_DIR"

    dirs_created=("$keys_dir" "$posts_dir" "$comments_dir" "$metadata_dir" "$WELL_KNOWN_DIR")
    success_human "Created directory structure"

    # Generate Ed25519 keypair
    if [ -f "$keys_dir/id_ed25519" ]; then
        json_error "init" "INVALID_STATE" "Keys already exist at $keys_dir/id_ed25519"
    fi

    info_human "Generating Ed25519 keypair..."
    ssh-keygen -t ed25519 -f "$keys_dir/id_ed25519" -N "" -C "polis@$(hostname)" > /dev/null 2>&1
    success_human "Generated Ed25519 keypair at $keys_dir/"

    # Get public key for metadata
    PUBKEY=$(cat "$keys_dir/id_ed25519.pub")

    # Create .well-known/polis metadata file with config section
    cat > "$WELL_KNOWN_DIR/polis" << EOF
{
  "version": "$VERSION",
  "author": "$(git config user.name || echo 'Unknown')",
  "email": "$(git config user.email || echo 'unknown@example.com')",
  "public_key": "$PUBKEY",
  "created": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "config": {
    "directories": {
      "keys": "$keys_dir",
      "posts": "$posts_dir",
      "comments": "$comments_dir",
      "versions": "$versions_dir"
    },
    "files": {
      "public_index": "$public_index",
      "blessed_comments": "$blessed_comments",
      "following_index": "$following_index"
    }
  }
}
EOF
    files_created+=(".well-known/polis")
    success_human "Created $WELL_KNOWN_DIR/polis metadata"

    # Create empty public.jsonl index
    > "$public_index"
    files_created+=("$public_index")
    success_human "Created $public_index index"

    # Create empty blessed-comments.json
    cat > "$blessed_comments" << EOF
{
  "version": "$VERSION",
  "comments": []
}
EOF
    files_created+=("$blessed_comments")
    success_human "Created $blessed_comments"

    # Create empty following.json
    cat > "$following_index" << EOF
{
  "version": "$VERSION",
  "following": []
}
EOF
    files_created+=("$following_index")
    success_human "Created $following_index"

    # Create .gitignore if it doesn't exist
    local private_key_path="$keys_dir/id_ed25519"
    if [ ! -f ".gitignore" ]; then
        cat > ".gitignore" << EOF
/polis
.env*
archive/
$private_key_path
EOF
        files_created+=(".gitignore")
        success_human "Created .gitignore (excludes private key)"
    fi

    # Copy .env.example to .env if .env doesn't exist
    local env_created=false
    if [ ! -f ".env" ]; then
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        local cli_dir="$(dirname "$script_dir")"
        local env_example="$cli_dir/.env.example"

        if [ -f "$env_example" ]; then
            cp "$env_example" ".env"
            files_created+=(".env")
            env_created=true
            success_human "Created .env from .env.example"
            warn "Please update .env with your configuration values"
        fi
    fi

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --argjson dirs "$(printf '%s\n' "${dirs_created[@]}" | jq -R . | jq -s .)" \
            --argjson files "$(printf '%s\n' "${files_created[@]}" | jq -R . | jq -s .)" \
            --arg private_key "$keys_dir/id_ed25519" \
            --arg public_key "$keys_dir/id_ed25519.pub" \
            --argjson env_created "$env_created" \
            '{
                directories_created: $dirs,
                files_created: $files,
                key_paths: {
                    private: $private_key,
                    public: $public_key
                },
                env_created: $env_created
            }')
        json_success "init" "$result"
    else
        success "Polis initialization complete!"
        info "Your public key has been added to $WELL_KNOWN_DIR/polis"
        info "Private key stored at $keys_dir/id_ed25519 (not committed to git)"
        if [ "$env_created" = true ]; then
            echo ""
            warn "ACTION REQUIRED: Update .env with your configuration values:"
            info "  - POLIS_BASE_URL: Your site's public URL"
            info "  - DISCOVERY_SERVICE_KEY: Your API key for blessing operations"
        fi
    fi
}

# Check if file has frontmatter
has_frontmatter() {
    local file="$1"
    [ "$(head -n 1 "$file")" = "---" ]
}

# Extract content without frontmatter
extract_content_without_frontmatter() {
    local file="$1"
    # Skip everything from first --- to second ---, then output the rest
    awk '/^---$/{if(++count==2){skip=0; next} skip=1; next} !skip' "$file"
}

# Extract frontmatter field value
extract_frontmatter_field() {
    local file="$1"
    local field="$2"
    awk -v field="$field:" '/^---$/{if(++count==2) exit} count==1 && $0 ~ "^"field{sub("^"field" *", ""); print; exit}' "$file"
}

# Extract version history lines
extract_version_history() {
    local file="$1"
    # More robust: extract all lines that are version entries
    # Start after version-history: and stop at next top-level field
    sed -n '/^version-history:/,/^[a-z-]/p' "$file" | grep '^  - sha256:' || true
}

# Extract in-reply-to section (for comments)
extract_in_reply_to() {
    local file="$1"
    # Extract the url and version lines from in-reply-to section
    sed -n '/^in-reply-to:/,/^[a-z-]/p' "$file" | grep -E '^  (url|version):' || true
}

# Extract title from first # heading in markdown file
extract_title() {
    local file="$1"
    # Find first line starting with # and extract the title
    local title=$(grep -m 1 '^#\s' "$file" | sed 's/^#\s*//')
    if [ -z "$title" ]; then
        # Fallback to filename without extension
        title=$(basename "$file" .md | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
    fi
    echo "$title"
}

# Calculate SHA-256 hash of file content
hash_content() {
    local file="$1"
    # Hash the entire file content
    if command -v sha256sum > /dev/null; then
        sha256sum "$file" | awk '{print $1}'
    elif command -v shasum > /dev/null; then
        shasum -a 256 "$file" | awk '{print $1}'
    else
        error "Neither sha256sum nor shasum found. Please install coreutils."
    fi
}

# Generate unified diff between two files (reverse: new -> old)
generate_version_diff() {
    local new_file="$1"
    local old_file="$2"
    # Generate unified diff from old to new (reverse direction for backward reconstruction)
    diff -u "$old_file" "$new_file" || true
}

# Get versions file path for a canonical file
# New structure: versions subdirectory in same directory as file
# Example: posts/2025/01/my-post.md -> posts/2025/01/.versions/my-post.md
# Directory name is configurable via VERSIONS_DIR_NAME
get_versions_file_path() {
    local canonical_file="$1"
    local dir=$(dirname "$canonical_file")
    local filename=$(basename "$canonical_file")
    echo "$dir/$VERSIONS_DIR_NAME/$filename"
}

# Initialize version history with full content (called on publish)
initialize_version_history() {
    local canonical_file="$1"
    local content_hash="$2"
    local timestamp="$3"
    local content="$4"

    # Determine versions file path
    local versions_file=$(get_versions_file_path "$canonical_file")
    local versions_dir=$(dirname "$versions_file")

    # Create .versions directory structure if it doesn't exist
    mkdir -p "$versions_dir"

    # Create versions file with header and first version as full content
    cat > "$versions_file" << EOF
# VERSION_FILE_FORMAT=1.0
# CANONICAL_FILE=$canonical_file
# CURRENT_HASH=sha256:$content_hash

[VERSION sha256:$content_hash]
TIMESTAMP=$timestamp
PARENT=none
FULL_CONTENT_START
$content
FULL_CONTENT_END

EOF
}

# Append version diff to history file
# NOTE: The diff format stored in .versions files is compatible with the standard
# Unix diff/patch utilities. Diffs are stored in unified diff format and can be
# applied using 'patch -R' to reconstruct previous versions.
append_version_to_history() {
    local canonical_file="$1"
    local old_hash="$2"
    local new_hash="$3"
    local timestamp="$4"
    local diff_content="$5"

    # Determine versions file path
    local versions_file=$(get_versions_file_path "$canonical_file")
    local versions_dir=$(dirname "$versions_file")

    # Create .versions directory structure if it doesn't exist
    mkdir -p "$versions_dir"

    # Create versions file if it doesn't exist
    if [ ! -f "$versions_file" ]; then
        cat > "$versions_file" << EOF
# VERSION_FILE_FORMAT=1.0
# CANONICAL_FILE=$canonical_file
# CURRENT_HASH=sha256:$new_hash

EOF
    else
        # Update CURRENT_HASH in header
        sed -i "s/^# CURRENT_HASH=.*/# CURRENT_HASH=sha256:$new_hash/" "$versions_file"
    fi

    # Append new version section
    cat >> "$versions_file" << EOF
[VERSION sha256:$new_hash]
TIMESTAMP=$timestamp
PARENT=sha256:$old_hash
DIFF_START
$diff_content
DIFF_END

EOF
}

# Extract diff for specific version from versions file
extract_diff_for_version() {
    local versions_file="$1"
    local version_hash="$2"

    # Extract content between DIFF_START and DIFF_END for the specified version
    awk -v version="$version_hash" '
        /^\[VERSION sha256:/ {
            if ($0 ~ version) {
                found=1
            } else {
                found=0
            }
        }
        found && /^DIFF_START$/ {
            in_diff=1
            next
        }
        found && in_diff && /^DIFF_END$/ {
            exit
        }
        found && in_diff {
            print
        }
    ' "$versions_file"
}

# Extract full content for specific version from versions file
extract_full_content_for_version() {
    local versions_file="$1"
    local version_hash="$2"

    # Extract content between FULL_CONTENT_START and FULL_CONTENT_END
    awk -v version="$version_hash" '
        /^\[VERSION sha256:/ {
            if ($0 ~ version) {
                found=1
            } else {
                found=0
            }
        }
        found && /^FULL_CONTENT_START$/ {
            in_content=1
            next
        }
        found && in_content && /^FULL_CONTENT_END$/ {
            exit
        }
        found && in_content {
            print
        }
    ' "$versions_file"
}

# Extract parent hash for specific version
extract_parent_hash() {
    local versions_file="$1"
    local version_hash="$2"

    # Find the PARENT= line for the specified version
    awk -v version="$version_hash" '
        /^\[VERSION sha256:/ {
            if ($0 ~ version) {
                found=1
            } else {
                found=0
            }
        }
        found && /^PARENT=/ {
            sub(/^PARENT=/, "")
            print
            exit
        }
    ' "$versions_file"
}

# Verify content matches expected hash
verify_version_integrity() {
    local content_file="$1"
    local expected_hash="$2"

    local actual_hash=$(hash_content "$content_file")

    if [ "sha256:$actual_hash" = "$expected_hash" ]; then
        return 0
    else
        return 1
    fi
}

# Reconstruct specific version from canonical file and diffs
reconstruct_version() {
    local canonical_file="$1"
    local target_hash="$2"
    local output_file="$3"

    local versions_file=$(get_versions_file_path "$canonical_file")

    # Check if versions file exists
    if [ ! -f "$versions_file" ]; then
        error "No version history found for $filename"
    fi

    # Get current version hash from versions file
    local current_hash=$(grep "^# CURRENT_HASH=" "$versions_file" | sed 's/^# CURRENT_HASH=//')

    # Check if target is the base version (has full content stored)
    local target_parent=$(extract_parent_hash "$versions_file" "$target_hash")
    if [ "$target_parent" = "none" ]; then
        # Target is base version - extract full content directly
        extract_full_content_for_version "$versions_file" "$target_hash" > "$output_file"
        # Verify integrity
        if ! verify_version_integrity "$output_file" "$target_hash"; then
            error "Integrity check failed for reconstructed version $target_hash"
        fi
        return 0
    fi

    # Extract current content (without frontmatter)
    local temp_current=$(mktemp)
    extract_content_without_frontmatter "$canonical_file" > "$temp_current"

    # Walk backward through version chain
    local current_version="$current_hash"
    local temp_work=$(mktemp)
    cp "$temp_current" "$temp_work"

    while [ "$current_version" != "$target_hash" ]; do
        # Get parent version first to check if we're at the base
        local parent_version=$(extract_parent_hash "$versions_file" "$current_version")

        # If parent is "none", we've reached the base but haven't found target
        if [ "$parent_version" = "none" ]; then
            rm -f "$temp_current" "$temp_work"
            error "Version $target_hash not found in history"
        fi

        # Extract diff for current version
        local diff_content=$(extract_diff_for_version "$versions_file" "$current_version")

        if [ -z "$diff_content" ]; then
            rm -f "$temp_current" "$temp_work"
            error "Version $target_hash not found in history"
        fi

        # Apply reverse patch (go backward in time)
        local temp_diff=$(mktemp)
        echo "$diff_content" > "$temp_diff"

        local temp_patched=$(mktemp)
        if patch -R -s -o "$temp_patched" "$temp_work" "$temp_diff" 2>/dev/null; then
            cp "$temp_patched" "$temp_work"
            rm -f "$temp_patched" "$temp_diff"
        else
            rm -f "$temp_current" "$temp_work" "$temp_patched" "$temp_diff"
            error "Failed to apply patch for version ${current_version:0:13}..."
        fi

        # Move to parent version
        current_version="$parent_version"

        if [ -z "$current_version" ]; then
            rm -f "$temp_current" "$temp_work"
            error "Version chain broken while looking for $target_hash"
        fi
    done

    # Copy reconstructed content to output
    cp "$temp_work" "$output_file"

    # Cleanup
    rm -f "$temp_current" "$temp_work"

    # Verify integrity
    if ! verify_version_integrity "$output_file" "$target_hash"; then
        error "Integrity check failed for reconstructed version $target_hash"
    fi
}

# ============================================================================
# BLESSING HELPER FUNCTIONS
# ============================================================================

# Extract author email from .well-known/polis
extract_author_from_wellknown() {
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        error "Polis not initialized. Run 'polis init' first."
    fi

    local author=$(grep -m 1 '"email"' "$WELL_KNOWN_DIR/polis" | sed 's/.*"email": *"\([^"]*\)".*/\1/')

    if [ -z "$author" ]; then
        error "Could not extract author email from .well-known/polis"
    fi

    echo "$author"
}

# Extract domain from POLIS_BASE_URL
# Uses bash parameter expansion for portability (works on both Linux and macOS)
extract_domain_from_url() {
    local url="$1"
    # Remove protocol (http:// or https://) using parameter expansion
    # ${url#*://} removes everything up to and including ://
    local domain="${url#*://}"
    # Remove path and trailing slash
    # ${domain%%/*} removes everything from the first / onwards
    domain="${domain%%/*}"
    echo "$domain"
}

# Check if a URL is a comment (vs a post)
# Comments are typically in /comments/ path
is_comment_url() {
    local url="$1"
    [[ "$url" =~ /comments/ ]]
}

# Fetch root_post for a comment URL from discovery service
# Returns: root_post URL or empty if not found/error
fetch_root_post_for_comment() {
    local comment_url="$1"

    if [ -z "$DISCOVERY_SERVICE_KEY" ]; then
        # Can't query without API key
        return 1
    fi

    # URL-encode the comment URL
    local encoded_url=$(jq -rn --arg url "$comment_url" '$url | @uri')

    local response=$(curl -s --max-time 10 \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${POLIS_COMMENTS_ENDPOINT}?url=${encoded_url}" 2>/dev/null)

    if [ -z "$response" ]; then
        return 1
    fi

    # Check for error response (comment not found in database)
    local error_msg=$(echo "$response" | jq -r '.error // empty' 2>/dev/null)
    if [ -n "$error_msg" ]; then
        return 1
    fi

    # Try to extract root_post from response
    local root_post=$(echo "$response" | jq -r '.root_post // empty' 2>/dev/null)

    if [ -n "$root_post" ] && [ "$root_post" != "null" ]; then
        echo "$root_post"
        return 0
    fi

    # Fallback: try in_reply_to (for older comments before nested threads)
    local in_reply_to=$(echo "$response" | jq -r '.in_reply_to // empty' 2>/dev/null)
    if [ -n "$in_reply_to" ] && [ "$in_reply_to" != "null" ]; then
        echo "$in_reply_to"
        return 0
    fi

    return 1
}

# ============================================================================
# DOMAIN MIGRATION HELPERS
# ============================================================================

# Collect all domains the user "cares about" for migration tracking
# Returns: newline-separated list of unique domains
collect_relevant_domains() {
    local domains=()

    # 1. Domains from following.json
    if [ -f "$FOLLOWING_INDEX" ]; then
        while IFS= read -r url; do
            local domain=$(extract_domain_from_url "$url")
            if [ -n "$domain" ]; then
                domains+=("$domain")
            fi
        done < <(jq -r '.following[].url // empty' "$FOLLOWING_INDEX" 2>/dev/null)
    fi

    # 2. Domains from blessed-comments.json (post URLs that have blessed comments)
    if [ -f "$BLESSED_COMMENTS" ]; then
        while IFS= read -r url; do
            local domain=$(extract_domain_from_url "$url")
            if [ -n "$domain" ]; then
                domains+=("$domain")
            fi
        done < <(jq -r '.posts[].url // empty' "$BLESSED_COMMENTS" 2>/dev/null)

        # Also check comment author domains
        while IFS= read -r url; do
            local domain=$(extract_domain_from_url "$url")
            if [ -n "$domain" ]; then
                domains+=("$domain")
            fi
        done < <(jq -r '.posts[].blessed[].url // empty' "$BLESSED_COMMENTS" 2>/dev/null)
    fi

    # 3. Domains from in-reply-to in local comments
    if [ -d "$COMMENTS_DIR" ]; then
        for file in $(find "$COMMENTS_DIR" -name "*.md" -type f 2>/dev/null); do
            local in_reply_to=$(extract_frontmatter_field "$file" "in-reply-to")
            # Handle nested YAML - extract URL from the block
            if [[ "$in_reply_to" == *"url:"* ]]; then
                in_reply_to=$(echo "$in_reply_to" | grep -oE 'https://[^[:space:]]+' | head -1)
            fi
            if [ -n "$in_reply_to" ]; then
                local domain=$(extract_domain_from_url "$in_reply_to")
                if [ -n "$domain" ]; then
                    domains+=("$domain")
                fi
            fi
        done
    fi

    # Deduplicate and output
    printf '%s\n' "${domains[@]}" | sort -u
}

# Query discovery service for migrations affecting specified domains
# Args: $1 = comma-separated domains
# Returns: JSON response with migrations array
query_domain_migrations() {
    local domains="$1"

    if [ -z "$POLIS_ENDPOINT_BASE" ] || [ -z "$DISCOVERY_SERVICE_KEY" ]; then
        echo '{"migrations":[],"count":0,"checked_domains":0}'
        return 1
    fi

    local endpoint="${POLIS_ENDPOINT_BASE}/migrations"
    local response=$(curl -s --max-time 30 \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${endpoint}?domains=${domains}" 2>/dev/null)

    if [ -z "$response" ]; then
        echo '{"migrations":[],"count":0,"checked_domains":0}'
        return 1
    fi

    echo "$response"
}

# Fetch public key from a domain's .well-known/polis
# Args: $1 = domain (e.g., "example.com")
# Returns: public key string or empty on failure
fetch_domain_public_key() {
    local domain="$1"
    local wellknown_url="https://${domain}/.well-known/polis"

    local response=$(curl -s --max-time 10 "$wellknown_url" 2>/dev/null)
    if [ -z "$response" ]; then
        return 1
    fi

    local public_key=$(echo "$response" | jq -r '.public_key // empty' 2>/dev/null)
    if [ -n "$public_key" ] && [ "$public_key" != "null" ]; then
        echo "$public_key"
        return 0
    fi

    return 1
}

# Update domain references in following.json
# Args: $1 = old_domain, $2 = new_domain
update_domain_in_following() {
    local old_domain="$1"
    local new_domain="$2"

    if [ ! -f "$FOLLOWING_INDEX" ]; then
        return 0
    fi

    local temp_file="${FOLLOWING_INDEX}.tmp"
    jq --arg old "https://$old_domain" \
       --arg new "https://$new_domain" \
       '.following |= map(if .url | startswith($old) then .url = ($new + (.url | ltrimstr($old))) else . end)' \
       "$FOLLOWING_INDEX" > "$temp_file" 2>/dev/null

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$FOLLOWING_INDEX"
        return 0
    else
        rm -f "$temp_file"
        return 1
    fi
}

# Update domain references in blessed-comments.json
# Args: $1 = old_domain, $2 = new_domain
update_domain_in_blessed_comments() {
    local old_domain="$1"
    local new_domain="$2"

    if [ ! -f "$BLESSED_COMMENTS" ]; then
        return 0
    fi

    local temp_file="${BLESSED_COMMENTS}.tmp"
    # Update both post URLs and blessed comment URLs
    jq --arg old "https://$old_domain" \
       --arg new "https://$new_domain" \
       '.posts |= map(
           (if .url | startswith($old) then .url = ($new + (.url | ltrimstr($old))) else . end) |
           .blessed |= map(if .url | startswith($old) then .url = ($new + (.url | ltrimstr($old))) else . end)
       )' \
       "$BLESSED_COMMENTS" > "$temp_file" 2>/dev/null

    if [ $? -eq 0 ]; then
        mv "$temp_file" "$BLESSED_COMMENTS"
        return 0
    else
        rm -f "$temp_file"
        return 1
    fi
}

# Update domain references in a comment markdown file (frontmatter only)
# Args: $1 = file path, $2 = old_domain, $3 = new_domain
update_domain_in_comment_file() {
    local file="$1"
    local old_domain="$2"
    local new_domain="$3"

    if [ ! -f "$file" ]; then
        return 1
    fi

    # Use sed to replace domain in frontmatter URLs
    # Note: This updates in-reply-to URLs, not the canonical_url (that's the commenter's domain)
    sed -i.bak "s|https://$old_domain/|https://$new_domain/|g" "$file"
    rm -f "${file}.bak"
    return 0
}

# Fetch comment content and extract excerpt (first ~100 chars)
fetch_comment_excerpt() {
    local comment_url="$1"
    local max_length=100

    # Fetch with timeout (follow redirects)
    local content=$(curl -sL --max-time 10 "$comment_url" 2>/dev/null)

    if [ -z "$content" ]; then
        echo "[Could not fetch]"
        return
    fi

    # Use existing helper to extract body (handles frontmatter correctly)
    local body=$(extract_body_from_content "$content")

    # If no body found, return placeholder
    if [ -z "$body" ]; then
        echo "[No content]"
        return
    fi

    # Get first meaningful line, strip markdown headers, trim whitespace
    body=$(echo "$body" | grep -v '^$' | head -1 | sed 's/^#* *//' | tr -d '\n')

    # Truncate to max_length and add ellipsis if longer
    if [ ${#body} -gt $max_length ]; then
        echo "${body:0:$max_length}..."
    else
        echo "$body"
    fi
}

# Format full hash to short hash (e.g., "sha256:abc123...xyz789" -> "abc123-xyz789")
format_short_hash() {
    local full_version="$1"
    # Remove sha256: prefix and extract first 6 and last 6 characters
    local hash=$(echo "$full_version" | sed 's/sha256://')
    echo "${hash:0:6}-${hash: -6}"
}

# Resolve short hash to full comment_version
# Searches pending requests for a matching hash prefix/suffix
resolve_short_hash() {
    local short_hash="$1"
    local domain="$2"  # Used to filter requests

    # Normalize: remove dash if present, lowercase
    local normalized=$(echo "$short_hash" | tr -d '-' | tr '[:upper:]' '[:lower:]')

    # Fetch all pending requests for this domain
    local response=$(curl -s \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${POLIS_BLESSING_REQUESTS_ENDPOINT}?in_reply_to_domain=${domain}&blessing_status=pending")

    # Search for matching comment_version
    # Match if hash starts with first 6 chars or ends with last 6 chars or contains both parts
    local full_version=$(echo "$response" | jq -r --arg hash "$normalized" '
        .requests[] |
        select(
            (.comment_version | gsub("sha256:"; "") | ascii_downcase) |
            (startswith($hash[0:6]) and endswith($hash | .[-6:]))
            or startswith($hash)
            or endswith($hash)
        ) |
        .comment_version
    ' 2>/dev/null | head -1)

    echo "$full_version"
}

# Fetch request details from blessing-requests API by comment_version
fetch_request_details() {
    local comment_version="$1"

    # Extract domain from POLIS_BASE_URL to filter requests
    local domain=$(echo "$POLIS_BASE_URL" | sed 's|https\?://||' | sed 's|/.*||')

    # Fetch pending requests for this domain
    local response=$(curl -s \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${POLIS_BLESSING_REQUESTS_ENDPOINT}?in_reply_to_domain=${domain}&blessing_status=pending")

    # Filter by comment_version - encode the version for URL safety
    local request_data=$(echo "$response" | jq -r --arg ver "$comment_version" '
        .requests[] | select(.comment_version == $ver)
    ' 2>/dev/null)

    # Check for API errors
    local error_msg=$(echo "$response" | jq -r '.error // empty' 2>/dev/null)
    if [ -n "$error_msg" ]; then
        echo "ERROR: API returned error: $error_msg" >&2
        return 1
    fi

    echo "$request_data"
}

# Prompt user for confirmation
prompt_confirmation() {
    local short_hash="$1"
    local request_json="$2"

    # Parse request details
    local author=$(echo "$request_json" | jq -r '.author')
    local comment_url=$(echo "$request_json" | jq -r '.comment_url')
    local in_reply_to=$(echo "$request_json" | jq -r '.in_reply_to')
    local timestamp=$(echo "$request_json" | jq -r '.timestamp')

    # Fetch comment content
    local excerpt=$(fetch_comment_excerpt "$comment_url")

    # Display request details
    echo ""
    info "Request ${short_hash}:"
    echo "    Author: $author"
    echo "    Comment: $comment_url"
    echo "    In reply to: $in_reply_to"
    echo "    Timestamp: $timestamp"
    echo ""
    echo "    Preview:"
    echo "    $excerpt"
    echo ""
}

# Display request details (for blessing operations)
display_request_details() {
    prompt_confirmation "$@"
}

# Update blessed-comments.json file
update_blessed_comments_json() {
    local comment_url="$1"
    local comment_version="$2"
    local in_reply_to="$3"
    local blessed_at="$4"

    local blessed_file="$BLESSED_COMMENTS"

    if [ ! -f "$blessed_file" ]; then
        error "blessed-comments.json not found. Run 'polis init' first."
    fi

    # Check if jq is available
    if ! command -v jq > /dev/null 2>&1; then
        error "jq is required but not installed. Please install jq to continue."
    fi

    local temp_file="${blessed_file}.tmp"

    # Use jq to update JSON
    jq --arg post "$in_reply_to" \
       --arg url "$comment_url" \
       --arg version "$comment_version" \
       --arg timestamp "$blessed_at" \
       '
       .comments |= (
         if any(.[]; .post == $post) then
           map(if .post == $post then
             .blessed += [{
               url: $url,
               version: $version,
               blessed_at: $timestamp
             }]
           else . end)
         else
           . + [{
             post: $post,
             blessed: [{
               url: $url,
               version: $version,
               blessed_at: $timestamp
             }]
           }]
         end
       )
       ' "$blessed_file" > "$temp_file"

    # Atomic replace
    mv "$temp_file" "$blessed_file"
}

# Remove comment from blessed-comments.json file
remove_from_blessed_comments_json() {
    local comment_url="$1"
    local in_reply_to="$2"

    local blessed_file="$BLESSED_COMMENTS"

    if [ ! -f "$blessed_file" ]; then
        # File doesn't exist, nothing to remove
        return 0
    fi

    # Check if jq is available
    if ! command -v jq > /dev/null 2>&1; then
        error "jq is required but not installed. Please install jq to continue."
    fi

    local temp_file="${blessed_file}.tmp"

    # Use jq to remove the comment from blessed array
    jq --arg post "$in_reply_to" \
       --arg url "$comment_url" \
       '
       .comments |= map(
         if .post == $post then
           .blessed |= map(select(.url != $url))
         else . end
       ) |
       # Remove post entries with empty blessed arrays
       .comments |= map(select(.blessed | length > 0))
       ' "$blessed_file" > "$temp_file"

    # Atomic replace
    mv "$temp_file" "$blessed_file"
}

# Fetch author email from author's .well-known/polis
# Args: $1 = author_url (e.g., "https://alice.com")
# Returns: email address (echoed to stdout)
# Exits: with error if fetch fails
fetch_author_email_from_wellknown() {
    local author_url="$1"

    # Normalize URL (remove trailing slash)
    author_url="${author_url%/}"

    # Construct .well-known URL
    local wellknown_url="${author_url}/.well-known/polis"

    # Fetch with curl
    local response=$(curl -s --max-time 10 "$wellknown_url" 2>&1)

    if [ $? -ne 0 ]; then
        error "Failed to fetch $wellknown_url
Check that the URL is accessible and the author has Polis initialized."
    fi

    # Parse JSON to extract email
    local email=$(echo "$response" | jq -r '.email // empty' 2>/dev/null)

    if [ -z "$email" ]; then
        error "No email found in $wellknown_url
Author may not have Polis properly configured."
    fi

    echo "$email"
}

# Fetch all blessing requests for a specific author on current user's posts
# Args: $1 = author_email, $2 = blessing_status_filter (optional: "pending", "blessed", "denied", or empty for all)
# Returns: JSON array of request objects (echoed to stdout)
fetch_comments_by_author() {
    local author_email="$1"
    local status_filter="$2"  # optional

    # Extract current user's domain
    local user_domain=$(extract_domain_from_url "$POLIS_BASE_URL")

    if [ -z "$user_domain" ]; then
        error "Invalid POLIS_BASE_URL. Cannot extract domain."
    fi

    # Fetch all requests for user's domain
    local response=$(curl -s \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${POLIS_BLESSING_REQUESTS_ENDPOINT}?in_reply_to_domain=${user_domain}")

    if [ $? -ne 0 ]; then
        error "Failed to connect to blessing requests endpoint"
    fi

    # Filter by author email (and optionally blessing_status)
    local filtered_result
    if [ -n "$status_filter" ]; then
        filtered_result=$(echo "$response" | jq --arg author "$author_email" --arg status "$status_filter" \
            '.requests | map(select(.author == $author and .blessing_status == $status))')
    else
        filtered_result=$(echo "$response" | jq --arg author "$author_email" \
            '.requests | map(select(.author == $author))')
    fi

    echo "$filtered_result"
}

# Extract base URL (protocol + domain) from a content URL
# Input:  https://alice.com/posts/2025/01/hello.md
# Output: https://alice.com
extract_base_url() {
    local url="$1"
    echo "$url" | sed -E 's|(https?://[^/]+).*|\1|'
}

# Fetch content from a remote URL
# Returns: content string or empty on error
fetch_remote_content() {
    local url="$1"
    curl -s --max-time 30 "$url" 2>/dev/null
}

# Fetch public key from author's .well-known/polis
# Input:  https://alice.com
# Output: ssh-ed25519 AAAA... (public key string)
fetch_remote_public_key() {
    local base_url="$1"
    local wellknown_url="${base_url}/.well-known/polis"
    local response=$(curl -s --max-time 10 "$wellknown_url" 2>/dev/null)

    if [ -z "$response" ]; then
        echo ""
        return 1
    fi

    local public_key=$(echo "$response" | jq -r '.public_key // empty')
    echo "$public_key"
}

# Extract frontmatter field from content string (not file)
# Args: $1=content, $2=field_name
extract_frontmatter_field_from_content() {
    local content="$1"
    local field="$2"
    echo "$content" | awk -v field="$field:" '/^---$/{if(++count==2) exit} count==1 && $0 ~ "^"field{sub("^"field" *", ""); print; exit}'
}

# Extract content body (without frontmatter) from content string
extract_body_from_content() {
    local content="$1"
    echo "$content" | awk '/^---$/{if(++count==2){skip=0; getline; print; next} skip=1; next} !skip'
}

# Verify signature of remote content
# Args: $1=content, $2=public_key, $3=author_email
# Returns: 0 if valid, 1 if invalid
verify_remote_signature() {
    local content="$1"
    local public_key="$2"
    local author_email="$3"

    # Extract signature from frontmatter (signature: only appears in frontmatter)
    local signature=$(echo "$content" | grep '^signature:' | sed 's/^signature: *//')

    if [ -z "$signature" ]; then
        return 1
    fi

    # Create temp files
    local temp_content=$(mktemp)
    local temp_sig=$(mktemp)
    local temp_allowed=$(mktemp)

    # Write public key to allowed_signers file format: email key-type key-data [comment]
    # The namespace "file" is specified via -n flag to ssh-keygen, not in allowed_signers
    echo "$author_email $public_key" > "$temp_allowed"

    # Write signature to temp file (restore PEM format)
    echo "-----BEGIN SSH SIGNATURE-----" > "$temp_sig"
    echo "$signature" >> "$temp_sig"
    echo "-----END SSH SIGNATURE-----" >> "$temp_sig"

    # Reconstruct the content without signature field (what was originally signed)
    echo "$content" | sed '/^signature:/d' > "$temp_content"

    # Verify using ssh-keygen
    local result=1
    if ssh-keygen -Y verify -f "$temp_allowed" -I "$author_email" -n file -s "$temp_sig" < "$temp_content" >/dev/null 2>&1; then
        result=0
    fi

    # Cleanup
    rm -f "$temp_content" "$temp_sig" "$temp_allowed"

    return $result
}

# Add an author URL to following.json
# Args: $1 = author_url, $2 = timestamp
add_to_following_json() {
    local author_url="$1"
    local timestamp="$2"
    local following_file="$FOLLOWING_INDEX"

    if [ ! -f "$following_file" ]; then
        error "following.json not found. Run 'polis init' first."
    fi

    # Check if jq is available
    if ! command -v jq > /dev/null 2>&1; then
        error "jq is required but not installed. Please install jq to continue."
    fi

    local temp_file="${following_file}.tmp"

    # Use jq to add author to following list (unique by URL)
    jq --arg url "$author_url" \
       --arg ts "$timestamp" \
       '.following |= (. + [{url: $url, followed_at: $ts}] | unique_by(.url))' \
       "$following_file" > "$temp_file"

    # Atomic replace
    mv "$temp_file" "$following_file"
}

# Remove an author URL from following.json
# Args: $1 = author_url
remove_from_following_json() {
    local author_url="$1"
    local following_file="$FOLLOWING_INDEX"

    if [ ! -f "$following_file" ]; then
        # File doesn't exist, nothing to remove
        return 0
    fi

    # Check if jq is available
    if ! command -v jq > /dev/null 2>&1; then
        error "jq is required but not installed. Please install jq to continue."
    fi

    local temp_file="${following_file}.tmp"

    # Use jq to remove author from following list
    jq --arg url "$author_url" \
       '.following |= map(select(.url != $url))' \
       "$following_file" > "$temp_file"

    # Atomic replace
    mv "$temp_file" "$following_file"
}

# Check if currently following an author
# Args: $1 = author_url
# Returns: 0 (true) if following, 1 (false) otherwise
is_following() {
    local author_url="$1"
    local following_file="$FOLLOWING_INDEX"

    if [ ! -f "$following_file" ]; then
        return 1
    fi

    # Check if URL exists in following array
    local count=$(jq --arg url "$author_url" \
        '.following | map(select(.url == $url)) | length' \
        "$following_file")

    [ "$count" -gt 0 ]
}

# Check if a comment URL is already in blessed-comments.json
# Args: $1 = comment_url
# Returns: 0 (true) if blessed, 1 (false) otherwise
is_comment_blessed() {
    local comment_url="$1"
    local blessed_file="$BLESSED_COMMENTS"

    if [ ! -f "$blessed_file" ]; then
        return 1
    fi

    # Check if URL exists in any blessed array
    local count=$(jq --arg url "$comment_url" \
        '[.comments[].blessed[] | select(.url == $url)] | length' \
        "$blessed_file" 2>/dev/null || echo "0")

    [ "$count" -gt 0 ]
}

# Sync blessed comments from discovery service to local blessed-comments.json
# Fetches all blessed comments for current user's posts and adds any missing entries
# Returns: count of newly synced comments (echoed to stdout)
# Rebuild blessed-comments.json entirely from discovery service
# This is a "full" rebuild - truncates local file and rebuilds from scratch
rebuild_blessed_comments_full() {
    local domain=$(extract_domain_from_url "$POLIS_BASE_URL")

    if [ -z "$domain" ]; then
        error "Could not determine domain from POLIS_BASE_URL"
    fi

    info "Rebuilding blessed-comments.json from discovery service..."

    # Fetch all blessed comments for our posts
    local response=$(curl -s \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${POLIS_BLESSING_REQUESTS_ENDPOINT}?in_reply_to_domain=${domain}&blessing_status=blessed" 2>/dev/null)

    # Initialize fresh blessed-comments.json
    echo "{\"version\":\"$VERSION\",\"comments\":[]}" > "$BLESSED_COMMENTS"

    # Check if response is valid JSON with requests
    local request_count=$(echo "$response" | jq -r '.count // 0' 2>/dev/null)
    if [ -z "$request_count" ] || [ "$request_count" = "0" ] || [ "$request_count" = "null" ]; then
        success "Rebuilt blessed-comments.json (0 blessed comments)"
        return
    fi

    local added_count=0

    # Process each blessed comment
    while IFS= read -r request; do
        [ -z "$request" ] && continue

        local comment_url=$(echo "$request" | jq -r '.comment_url')
        local comment_version=$(echo "$request" | jq -r '.comment_version')
        local in_reply_to=$(echo "$request" | jq -r '.in_reply_to')
        local blessed_at=$(echo "$request" | jq -r '.blessed_at // empty')

        # Use current timestamp if blessed_at is empty
        if [ -z "$blessed_at" ]; then
            blessed_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi

        update_blessed_comments_json "$comment_url" "$comment_version" "$in_reply_to" "$blessed_at"
        added_count=$((added_count + 1))
    done < <(echo "$response" | jq -c '.requests[]' 2>/dev/null)

    success "Rebuilt blessed-comments.json ($added_count blessed comments)"
}

sync_blessed_comments() {
    local domain=$(extract_domain_from_url "$POLIS_BASE_URL")

    if [ -z "$domain" ]; then
        echo "0"
        return
    fi

    # Fetch all blessed comments for our posts from discovery service
    local response=$(curl -s \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${POLIS_BLESSING_REQUESTS_ENDPOINT}?in_reply_to_domain=${domain}&blessing_status=blessed" 2>/dev/null)

    # Check if response is valid JSON with requests
    local request_count=$(echo "$response" | jq -r '.count // 0' 2>/dev/null)
    if [ -z "$request_count" ] || [ "$request_count" = "0" ] || [ "$request_count" = "null" ]; then
        echo "0"
        return
    fi

    local synced_count=0

    # Process each blessed comment
    # Note: Using process substitution to avoid subshell variable scope issues
    while IFS= read -r request; do
        [ -z "$request" ] && continue

        local comment_url=$(echo "$request" | jq -r '.comment_url')
        local comment_version=$(echo "$request" | jq -r '.comment_version')
        local in_reply_to=$(echo "$request" | jq -r '.in_reply_to')
        local blessed_at=$(echo "$request" | jq -r '.blessed_at // empty')

        # Use current timestamp if blessed_at is empty
        if [ -z "$blessed_at" ]; then
            blessed_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        fi

        # Check if already in blessed-comments.json
        if ! is_comment_blessed "$comment_url"; then
            update_blessed_comments_json "$comment_url" "$comment_version" "$in_reply_to" "$blessed_at"
            synced_count=$((synced_count + 1))
        fi
    done < <(echo "$response" | jq -c '.requests[]' 2>/dev/null)

    echo "$synced_count"
}

# Get comment ID by URL
# Args: $1 = comment_url
# Returns: comment id (echoed to stdout), or empty string if not found
get_comment_id_by_url() {
    local comment_url="$1"

    # URL encode the comment_url
    local encoded_url=$(jq -rn --arg url "$comment_url" '$url | @uri')

    # Call comments endpoint
    local response=$(curl -s \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${POLIS_COMMENTS_ENDPOINT}?url=${encoded_url}")

    # Check if we got a valid response
    local comment_id=$(echo "$response" | jq -r '.id // empty' 2>/dev/null)

    if [ -z "$comment_id" ] || [ "$comment_id" = "null" ]; then
        return 1
    fi

    echo "$comment_id"
}

# Get all blessed comment URLs from a specific author domain
# Args: $1 = author_url (e.g., "https://polis-poc.vercel.app/")
# Returns: JSON array of comment URLs
get_blessed_comment_urls_by_author() {
    local author_url="$1"
    local blessed_file="$BLESSED_COMMENTS"

    if [ ! -f "$blessed_file" ]; then
        echo "[]"
        return
    fi

    # Normalize URL (remove trailing slash)
    author_url="${author_url%/}"

    # Extract all blessed comment URLs that start with author_url
    jq --arg author_prefix "${author_url}/" \
        '[.comments[].blessed[] | select(.url | startswith($author_prefix)) | .url]' \
        "$blessed_file"
}

# Format blessing requests as a table
format_blessing_table() {
    local requests_json="$1"

    # Validate JSON and check if there are any requests
    local count=$(echo "$requests_json" | jq -r '.count // 0' 2>/dev/null)

    # Handle invalid JSON or null count
    if [ -z "$count" ] || [ "$count" = "null" ]; then
        count=0
    fi

    # Check if count is zero
    if [ "$count" -eq 0 ] 2>/dev/null || [ "$count" = "0" ]; then
        info "No pending blessing requests found"
        return
    fi

    # Print header
    printf "\n%-15s %-20s %-60s %s\n" "Hash" "Author" "Comment URL" "Timestamp"
    printf "%.sâ”€" {1..120}
    echo ""

    # Process each request (with null check)
    local requests_data=$(echo "$requests_json" | jq -r '.requests // [] | .[] | "\(.comment_version)|\(.author)|\(.comment_url)|\(.timestamp)"' 2>/dev/null)

    if [ -z "$requests_data" ]; then
        info "No pending blessing requests found"
        return
    fi

    echo "$requests_data" | while IFS='|' read -r version author url timestamp; do
        # Skip empty lines
        [ -z "$version" ] && continue

        # Format short hash from comment_version
        local short_hash=$(format_short_hash "$version")
        # Truncate long fields for display
        local display_author=$(echo "$author" | cut -c1-20)
        local display_url=$(echo "$url" | cut -c1-60)
        # Format timestamp: replace T with space, keep timezone
        local display_timestamp=$(echo "$timestamp" | tr 'T' ' ')

        printf "%-15s %-20s %-60s %s\n" "$short_hash" "$display_author" "$display_url" "$display_timestamp"
    done

    echo ""
    success "Found $count pending request(s)"
    info "Run 'polis preview <URL>' to see comment details"
    info "Run 'polis blessing grant <hash>' to bless or 'polis blessing deny <hash>' to deny"
}

# Rebuild public.json index from all posts and comments
rebuild_index() {
    info "Rebuilding public.jsonl index..."

    # Check if jq is available
    if ! command -v jq > /dev/null 2>&1; then
        error "jq not found. Please install jq: sudo apt-get install jq (or brew install jq on macOS)"
    fi

    # Truncate the index file
    > "$PUBLIC_INDEX"

    # Counters
    local post_count=0
    local comment_count=0

    # Helper function to process a file and append JSONL entry
    process_file() {
        local file="$1"
        local filename=$(basename "$file")

        # Skip hash snapshot files (format: abc123-xyz789.md) and files in versions directory
        if [[ "$filename" =~ ^[a-f0-9]{6}-[a-f0-9]{6}\.md$ ]] || [[ "$file" =~ /$VERSIONS_DIR_NAME/ ]]; then
            return
        fi

        # Extract frontmatter fields
        local title=$(grep -m 1 '^title:' "$file" | sed 's/^title: *//')
        local published=$(grep -m 1 '^published:' "$file" | sed 's/^published: *//')
        local version=$(grep -m 1 '^current-version:' "$file" | sed 's/^current-version: *//')
        local content_type=$(grep -m 1 '^type:' "$file" | sed 's/^type: *//')

        # Skip if missing required fields
        if [ -z "$title" ] || [ -z "$published" ] || [ -z "$version" ]; then
            return
        fi

        # Create JSONL entry based on content type
        if [ "$content_type" = "comment" ]; then
            # Extract in-reply-to for comments
            local reply_url=$(grep -m 1 '^  url:' "$file" | sed 's/^  url: *//')
            local reply_version=$(grep -m 1 '^  version:' "$file" | sed 's/^  version: *//')

            jq -nc \
                --arg type "comment" \
                --arg path "$file" \
                --arg title "$title" \
                --arg published "$published" \
                --arg current_version "$version" \
                --arg reply_url "$reply_url" \
                --arg reply_version "$reply_version" \
                '{
                    type: $type,
                    path: $path,
                    title: $title,
                    published: $published,
                    current_version: $current_version,
                    in_reply_to: {
                        url: $reply_url,
                        version: ($reply_version // null)
                    }
                }' >> "$PUBLIC_INDEX"

            comment_count=$((comment_count + 1))
        else
            jq -nc \
                --arg type "post" \
                --arg path "$file" \
                --arg title "$title" \
                --arg published "$published" \
                --arg current_version "$version" \
                '{
                    type: $type,
                    path: $path,
                    title: $title,
                    published: $published,
                    current_version: $current_version
                }' >> "$PUBLIC_INDEX"

            post_count=$((post_count + 1))
        fi
    }

    # Process all markdown files in posts/
    if [ -d "$POSTS_DIR" ]; then
        while IFS= read -r -d '' file; do
            process_file "$file"
        done < <(find "$POSTS_DIR" -name "*.md" -type f -print0 | sort -z)
    fi

    # Process all markdown files in comments/
    if [ -d "$COMMENTS_DIR" ]; then
        while IFS= read -r -d '' file; do
            process_file "$file"
        done < <(find "$COMMENTS_DIR" -name "*.md" -type f -print0 | sort -z)
    fi

    local total_count=$((post_count + comment_count))
    success "Rebuilt public.jsonl ($total_count entries: $post_count posts, $comment_count comments)"
}

# Append a single entry to public.jsonl
# Used by publish/comment for incremental updates
append_to_index() {
    local file_path="$1"
    local entry_type="$2"  # "post" or "comment"

    # Extract frontmatter fields
    local title=$(grep -m 1 '^title:' "$file_path" | sed 's/^title: *//')
    local published=$(grep -m 1 '^published:' "$file_path" | sed 's/^published: *//')
    local current_version=$(grep -m 1 '^current-version:' "$file_path" | sed 's/^current-version: *//')

    if [ "$entry_type" = "comment" ]; then
        # Extract in-reply-to for comments
        local reply_url=$(grep -m 1 '^  url:' "$file_path" | sed 's/^  url: *//')
        local reply_version=$(grep -m 1 '^  version:' "$file_path" | sed 's/^  version: *//')

        jq -nc \
            --arg type "comment" \
            --arg path "$file_path" \
            --arg title "$title" \
            --arg published "$published" \
            --arg current_version "$current_version" \
            --arg reply_url "$reply_url" \
            --arg reply_version "$reply_version" \
            '{
                type: $type,
                path: $path,
                title: $title,
                published: $published,
                current_version: $current_version,
                in_reply_to: {
                    url: $reply_url,
                    version: ($reply_version // null)
                }
            }' >> "$PUBLIC_INDEX"
    else
        jq -nc \
            --arg type "post" \
            --arg path "$file_path" \
            --arg title "$title" \
            --arg published "$published" \
            --arg current_version "$current_version" \
            '{
                type: $type,
                path: $path,
                title: $title,
                published: $published,
                current_version: $current_version
            }' >> "$PUBLIC_INDEX"
    fi
}

# Sign file with Ed25519 key
sign_file() {
    local file="$1"
    local keyfile="$KEYS_DIR/id_ed25519"

    if [ ! -f "$keyfile" ]; then
        error "Private key not found. Run 'polis init' first."
    fi

    # Use ssh-keygen -Y sign to sign the file
    # The signature will be written to $file.sig
    ssh-keygen -Y sign -f "$keyfile" -n file "$file" > /dev/null 2>&1

    # Extract the signature (skip the header/footer lines, get base64 content)
    local sig=$(grep -v '^-----' "$file.sig" | tr -d '\n')

    # Clean up signature file
    rm -f "$file.sig"

    echo "$sig"
}

# Re-sign a file with current key (preserves all metadata, updates signature)
# Works for both posts and comments
resign_file() {
    local input_file="$1"

    if [ ! -f "$input_file" ]; then
        return 1
    fi

    if ! has_frontmatter "$input_file"; then
        return 1
    fi

    # Extract existing metadata
    local title=$(extract_frontmatter_field "$input_file" "title")
    local original_published=$(extract_frontmatter_field "$input_file" "published")
    local content_type=$(extract_frontmatter_field "$input_file" "type")
    local current_version=$(extract_frontmatter_field "$input_file" "current-version")

    # Extract content without frontmatter
    local content_only=$(mktemp)
    extract_content_without_frontmatter "$input_file" > "$content_only"

    # Extract existing version history
    local version_history=$(extract_version_history "$input_file")

    # Build frontmatter (without signature)
    local frontmatter_template
    if [ "$content_type" = "comment" ]; then
        # Extract in-reply-to section for comments
        local in_reply_to=$(extract_in_reply_to "$input_file")
        frontmatter_template="---
title: $title
type: comment
published: $original_published
generator: polis-cli/$VERSION
in-reply-to:
$in_reply_to
current-version: $current_version
version-history:
$version_history
---"
    else
        frontmatter_template="---
title: $title
published: $original_published
generator: polis-cli/$VERSION
current-version: $current_version
version-history:
$version_history
---"
    fi

    # Create temporary file with frontmatter + content (for signing)
    local temp_file=$(mktemp)
    echo "$frontmatter_template" > "$temp_file"
    echo "" >> "$temp_file"
    cat "$content_only" >> "$temp_file"

    # Sign the file
    local signature=$(sign_file "$temp_file")

    # Create final frontmatter with signature
    local frontmatter
    if [ "$content_type" = "comment" ]; then
        local in_reply_to=$(extract_in_reply_to "$input_file")
        frontmatter="---
title: $title
type: comment
published: $original_published
generator: polis-cli/$VERSION
in-reply-to:
$in_reply_to
current-version: $current_version
version-history:
$version_history
signature: $signature
---"
    else
        frontmatter="---
title: $title
published: $original_published
generator: polis-cli/$VERSION
current-version: $current_version
version-history:
$version_history
signature: $signature
---"
    fi

    # Write back to file
    echo "$frontmatter" > "$input_file"
    echo "" >> "$input_file"
    cat "$content_only" >> "$input_file"

    # Clean up temp files
    rm -f "$temp_file" "$content_only"

    return 0
}

# Update .well-known/polis with new public key
update_wellknown_pubkey() {
    local new_pubkey=$(cat "$KEYS_DIR/id_ed25519.pub")

    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        return 1
    fi

    # Update public_key field using jq
    local temp_file=$(mktemp)
    jq --arg key "$new_pubkey" '.public_key = $key' "$WELL_KNOWN_DIR/polis" > "$temp_file"
    mv "$temp_file" "$WELL_KNOWN_DIR/polis"

    return 0
}

# Command: polis beseech <filename>
# Request blessing from post author for a comment
# Internal function for file-based beseech (used by auto-beseech in comment/republish)
_internal_beseech_from_file() {
    local input_file="$1"

    if [ -z "$input_file" ]; then
        json_error "beseech" "INVALID_INPUT" "Usage: _internal_beseech_from_file <filename>"
    fi

    if [ ! -f "$input_file" ]; then
        json_error "beseech" "FILE_NOT_FOUND" "File not found: $input_file"
    fi

    # Check if file has frontmatter
    if ! has_frontmatter "$input_file"; then
        json_error "beseech" "INVALID_INPUT" "File has no frontmatter"
    fi

    # Check if file is a comment (only comments can be beseeched)
    local content_type=$(extract_frontmatter_field "$input_file" "type")
    if [ "$content_type" != "comment" ]; then
        json_error "beseech" "INVALID_INPUT" "File is not a comment. Only comments can request blessing from discovery service."
    fi

    info_human "Requesting blessing from discovery service..."
    if [ "$JSON_MODE" = false ]; then
        echo ""
    fi

    # Extract comment metadata
    local title=$(extract_frontmatter_field "$input_file" "title")
    local published=$(extract_frontmatter_field "$input_file" "published")
    local version=$(extract_frontmatter_field "$input_file" "current-version")
    local in_reply_to=$(extract_in_reply_to "$input_file")

    # Parse in-reply-to section
    local reply_url=$(echo "$in_reply_to" | grep 'url:' | sed 's/.*url: *//')
    local reply_version=$(echo "$in_reply_to" | grep 'version:' | sed 's/.*version: *//')
    local root_post=$(echo "$in_reply_to" | grep 'root-post:' | sed 's/.*root-post: *//')

    # Fallback: if no root-post in frontmatter, use reply_url (for backward compatibility)
    if [ -z "$root_post" ]; then
        root_post="$reply_url"
    fi

    # Get author info from .well-known/polis
    local author=""
    if [ -f "$WELL_KNOWN_DIR/polis" ]; then
        author=$(grep -m 1 '"email"' "$WELL_KNOWN_DIR/polis" | sed 's/.*"email": *"\([^"]*\)".*/\1/')
    fi

    # Validation checks
    if [ -z "$version" ]; then
        json_error "beseech" "INVALID_INPUT" "Missing current-version in frontmatter"
    fi
    if [ -z "$reply_url" ]; then
        json_error "beseech" "INVALID_INPUT" "Missing in-reply-to URL in frontmatter"
    fi
    if [ -z "$published" ]; then
        json_error "beseech" "INVALID_INPUT" "Missing published date in frontmatter"
    fi
    if [ -z "$author" ]; then
        json_error "beseech" "INVALID_INPUT" "Missing author email. Set it in .well-known/polis config file."
    fi

    # Get configuration from environment variables
    local base_url="$POLIS_BASE_URL"
    local discovery_endpoint="$POLIS_BESEECH_ENDPOINT"

    if [ -z "$base_url" ]; then
        json_error "beseech" "INVALID_INPUT" "POLIS_BASE_URL not set. Set it with: export POLIS_BASE_URL=https://yourdomain.com"
    fi

    if [ -z "$discovery_endpoint" ]; then
        json_error "beseech" "INVALID_INPUT" "POLIS_BESEECH_ENDPOINT not set. Set it with: export POLIS_BESEECH_ENDPOINT=https://xxx.supabase.co/functions/v1/beseech"
    fi

    # Construct proper HTTPS comment URL
    # Convert local file path to public URL
    # Example: comments/my-comment.md -> https://yourdomain.com/comments/my-comment.md
    local comment_url="$base_url/$input_file"

    # Build canonical JSON payload (WITHOUT signature field)
    # This is what we'll sign
    # IMPORTANT: Use printf (not heredoc) to avoid trailing newline
    local canonical_payload
    if [ -n "$reply_version" ]; then
        canonical_payload=$(printf '{"comment_url":"%s","comment_version":"%s","in_reply_to":"%s","in_reply_to_version":"%s","root_post":"%s","author":"%s","timestamp":"%s"}' \
            "$comment_url" "$version" "$reply_url" "$reply_version" "$root_post" "$author" "$published")
    else
        canonical_payload=$(printf '{"comment_url":"%s","comment_version":"%s","in_reply_to":"%s","root_post":"%s","author":"%s","timestamp":"%s"}' \
            "$comment_url" "$version" "$reply_url" "$root_post" "$author" "$published")
    fi

    # Sign the canonical JSON
    # Create a temporary file with the canonical payload
    local temp_file=$(mktemp)
    echo -n "$canonical_payload" > "$temp_file"

    # Sign using ssh-keygen
    local keyfile="$KEYS_DIR/id_ed25519"
    if [ ! -f "$keyfile" ]; then
        rm -f "$temp_file"
        error "Private key not found. Run 'polis init' first."
    fi

    ssh-keygen -Y sign -f "$keyfile" -n file "$temp_file" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        rm -f "$temp_file" "$temp_file.sig"
        json_error "beseech" "SIGNATURE_ERROR" "Failed to sign payload. Check your private key."
    fi

    # Read the full signature (including PEM headers)
    local signature=""
    if [ -f "$temp_file.sig" ]; then
        signature=$(cat "$temp_file.sig")
    fi

    # Clean up temporary files
    rm -f "$temp_file" "$temp_file.sig"

    if [ -z "$signature" ]; then
        json_error "beseech" "SIGNATURE_ERROR" "Failed to generate signature"
    fi

    # Build final JSON payload with signature
    # Need to escape the signature properly for JSON
    local signature_escaped=$(echo "$signature" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/"/\\"/g')

    local final_payload
    if [ -n "$reply_version" ]; then
        final_payload=$(cat << EOF
{
  "comment_url": "$comment_url",
  "comment_version": "$version",
  "in_reply_to": "$reply_url",
  "in_reply_to_version": "$reply_version",
  "root_post": "$root_post",
  "author": "$author",
  "timestamp": "$published",
  "signature": "$signature_escaped"
}
EOF
)
    else
        final_payload=$(cat << EOF
{
  "comment_url": "$comment_url",
  "comment_version": "$version",
  "in_reply_to": "$reply_url",
  "root_post": "$root_post",
  "author": "$author",
  "timestamp": "$published",
  "signature": "$signature_escaped"
}
EOF
)
    fi

    # Send HTTP POST request to discovery service
    info_human "Sending blessing request to discovery service..."
    if [ "$JSON_MODE" = false ]; then
        echo "  URL: $comment_url"
        echo "  Reply to: $reply_url"
        echo ""
    fi

    local response
    local http_code

    # Make the HTTP request and capture both response body and status code
    response=$(curl -s -w "\n%{http_code}" \
        --location --request POST "$discovery_endpoint" \
        --header "${DISCOVERY_SERVICE_KEY:+Authorization: Bearer $DISCOVERY_SERVICE_KEY}" \
        --header 'Content-Type: application/json' \
        --data "$final_payload" 2>&1)

    # Extract HTTP status code (last line)
    http_code=$(echo "$response" | tail -n 1)
    # Extract response body (everything except last line)
    response=$(echo "$response" | sed '$d')

    # Handle response based on HTTP status code
    case "$http_code" in
        201)
            # Parse status from server response (blessed or pending)
            local response_status=$(echo "$response" | jq -r '.status // "pending"')
            local blessed_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

            if [ "$response_status" = "blessed" ]; then
                # Auto-blessed! Update blessed-comments.json
                update_blessed_comments_json "$comment_url" "$version" "$reply_url" "$blessed_at"

                if [ "$JSON_MODE" = true ]; then
                    local result=$(jq -n \
                        --arg url "$comment_url" \
                        --arg version "$version" \
                        --arg reply_to "$reply_url" \
                        --arg msg "Comment automatically blessed" \
                        --arg status "blessed" \
                        --argjson auto_blessed "true" \
                        '{
                            comment_url: $url,
                            comment_version: $version,
                            in_reply_to: $reply_to,
                            auto_blessed: $auto_blessed,
                            discovery_response: {
                                success: true,
                                message: $msg,
                                status: $status
                            }
                        }')
                    json_success "beseech" "$result"
                else
                    success "Comment automatically blessed!"
                    echo ""
                    info "The post author follows you, so your comment was auto-approved."
                    info "Added to blessed-comments.json"
                fi
            else
                # Pending - existing behavior
                if [ "$JSON_MODE" = true ]; then
                    local result=$(jq -n \
                        --arg url "$comment_url" \
                        --arg version "$version" \
                        --arg reply_to "$reply_url" \
                        --arg msg "Beseech request recorded" \
                        --arg status "pending" \
                        --argjson auto_blessed "false" \
                        '{
                            comment_url: $url,
                            comment_version: $version,
                            in_reply_to: $reply_to,
                            auto_blessed: $auto_blessed,
                            discovery_response: {
                                success: true,
                                message: $msg,
                                status: $status
                            }
                        }')
                    json_success "beseech" "$result"
                else
                    success "Blessing request sent successfully!"
                    echo ""
                    info "Your comment is now pending blessing from the post author."
                    info "Once blessed, it will appear in the public comment feed."
                fi
            fi
            ;;
        403)
            json_error "beseech" "SIGNATURE_ERROR" "Signature verification failed (HTTP 403). Possible causes: 1) Public key doesn't match private key, 2) .well-known/polis not accessible, 3) Public key format is incorrect. Response: $response"
            ;;
        409)
            if [ "$JSON_MODE" = true ]; then
                local result=$(jq -n \
                    --arg url "$comment_url" \
                    --arg version "$version" \
                    --arg reply_to "$reply_url" \
                    --arg msg "Comment version already submitted" \
                    --arg status "duplicate" \
                    '{
                        comment_url: $url,
                        comment_version: $version,
                        in_reply_to: $reply_to,
                        discovery_response: {
                            success: true,
                            message: $msg,
                            status: $status
                        }
                    }')
                json_success "beseech" "$result"
            else
                warn "This comment version was already submitted (HTTP 409)"
                echo ""
                info "This is normal if you've already requested blessing for this exact version before."
            fi
            ;;
        400)
            json_error "beseech" "INVALID_INPUT" "Invalid data sent to discovery service (HTTP 400): $response"
            ;;
        401)
            json_error "beseech" "API_ERROR" "Authentication failed (HTTP 401). Check your DISCOVERY_SERVICE_KEY."
            ;;
        500|502|503|504)
            json_error "beseech" "API_ERROR" "Discovery service error (HTTP $http_code). Please try again later."
            ;;
        *)
            if [ -z "$http_code" ] || [ "$http_code" = "000" ]; then
                json_error "beseech" "API_ERROR" "Failed to connect to discovery service. Check your internet connection and POLIS_BESEECH_ENDPOINT."
            else
                json_error "beseech" "API_ERROR" "Unexpected response from discovery service (HTTP $http_code): $response"
            fi
            ;;
    esac
}

# Command: polis blessing beseech <request-id>
# Retry or check a blessing request by ID
# This command is RARELY needed - polis comment/republish auto-request blessings
cmd_blessing_beseech() {
    local comment_id="$1"

    # Validate input
    if [ -z "$comment_id" ]; then
        json_error "blessing-beseech" "INVALID_INPUT" \
            "Usage: polis blessing beseech <request-id>"
    fi

    # Validate comment_id is numeric
    if ! [[ "$comment_id" =~ ^[0-9]+$ ]]; then
        json_error "blessing-beseech" "INVALID_INPUT" \
            "Request ID must be a number (e.g., 42)"
    fi

    # Check prerequisites
    if [ -z "$POLIS_BESEECH_ENDPOINT" ]; then
        json_error "blessing-beseech" "INVALID_STATE" \
            "POLIS_BESEECH_ENDPOINT not set. See 'polis help' for configuration."
    fi

    info_human "Fetching blessing request #$comment_id from discovery service..."

    # Construct requests endpoint (derive from beseech endpoint)
    local requests_endpoint="${POLIS_BESEECH_ENDPOINT/beseech/requests}"

    # Fetch request by ID
    local response=$(curl -s \
        "${requests_endpoint}?id=${comment_id}" \
        ${DISCOVERY_SERVICE_KEY:+-H "Authorization: Bearer $DISCOVERY_SERVICE_KEY"})

    # Parse response
    local count=$(echo "$response" | jq -r '.count // 0')

    if [ "$count" -eq 0 ]; then
        json_error "blessing-beseech" "NOT_FOUND" \
            "Request #$comment_id not found in discovery service"
    fi

    # Extract request data
    local comment_url=$(echo "$response" | jq -r '.requests[0].comment_url')
    local comment_version=$(echo "$response" | jq -r '.requests[0].comment_version')
    local in_reply_to=$(echo "$response" | jq -r '.requests[0].in_reply_to')
    local blessing_status=$(echo "$response" | jq -r '.requests[0].blessing_status // "unknown"')

    info_human "Found request #$comment_id (status: $blessing_status)"
    info_human "Comment: $comment_url"
    info_human "Reply to: $in_reply_to"

    # Display current status (if already blessed/denied)
    if [ "$blessing_status" = "blessed" ]; then
        success_human "This request is already blessed!"
        info_human "No action needed - comment is approved."
        if [ "$JSON_MODE" = true ]; then
            json_success "blessing-beseech" '{"status":"already_blessed","comment_id":'$comment_id'}'
        fi
        return 0
    fi

    if [ "$blessing_status" = "denied" ]; then
        info_human "This request was previously denied."
        info_human "Re-submitting will create a new blessing request..."
    fi

    # Try to map comment_url to local file path
    # Example: https://example.com/comments/2025/01/my-comment.md â†’ comments/2025/01/my-comment.md
    local local_file=""
    if [ -n "$POLIS_BASE_URL" ]; then
        local_file="${comment_url#$POLIS_BASE_URL/}"
    fi

    if [ -f "$local_file" ]; then
        info_human "Found local file: $local_file"
        info_human "Re-reading file and creating new beseech request..."

        # Call the internal beseech logic with the local file
        _internal_beseech_from_file "$local_file"
    else
        info_human "Local file not found: $local_file"
        error "Cannot re-beseech without local file.

To retry this blessing request, ensure the comment file exists locally at:
  $local_file

Or set POLIS_BASE_URL to match your comment URL domain."
    fi
}

# Command: polis comment <filename>
cmd_comment() {
    # Parse command-specific flags first
    local explicit_filename=""
    local explicit_title=""
    local explicit_reply_to=""
    local positional_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            --filename)
                explicit_filename="$2"
                shift 2
                ;;
            --title)
                explicit_title="$2"
                shift 2
                ;;
            --reply-to)
                explicit_reply_to="$2"
                shift 2
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    # Restore positional arguments
    set -- "${positional_args[@]}"

    local input_file="$1"

    if [ -z "$input_file" ]; then
        json_error "comment" "INVALID_INPUT" "Usage: polis comment <filename> [<reply-to-url>]\n       polis comment - <reply-to-url> [--filename <name>] [--title <title>]"
    fi

    if [ ! -f "$KEYS_DIR/id_ed25519" ]; then
        json_error "comment" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Check for stdin mode
    local stdin_mode=false
    local temp_stdin=""

    if [ "$input_file" = "-" ]; then
        stdin_mode=true

        # Verify stdin is not a terminal (has actual content)
        if [ -t 0 ]; then
            json_error "comment" "INVALID_INPUT" "No stdin content. Use: echo 'content' | polis comment - <reply-to-url>"
        fi

        # Create temp file and read stdin
        temp_stdin=$(mktemp)
        cat > "$temp_stdin"

        # Verify content
        if [ ! -s "$temp_stdin" ]; then
            rm -f "$temp_stdin"
            json_error "comment" "INVALID_INPUT" "Stdin content is empty"
        fi

        # Point input_file to temp file
        input_file="$temp_stdin"

        info_human "Reading content from stdin..."
    else
        # Regular file mode - check file exists
        if [ ! -f "$input_file" ]; then
            json_error "comment" "FILE_NOT_FOUND" "File not found: $input_file"
        fi
    fi

    # Ensure temp file cleanup on exit or error
    cleanup_stdin() {
        if [ -n "$temp_stdin" ] && [ -f "$temp_stdin" ]; then
            rm -f "$temp_stdin"
        fi
    }
    trap cleanup_stdin EXIT ERR

    # Check if file already has frontmatter (already published)
    # Skip this check for stdin mode as stdin content is always new
    if [ "$stdin_mode" = false ] && has_frontmatter "$input_file"; then
        json_error "comment" "INVALID_STATE" "File already has frontmatter. Use a new file for comments."
    fi

    # Store original file path for cleanup later
    local original_file="$input_file"

    # Determine base filename
    local base_filename
    if [ "$stdin_mode" = true ]; then
        if [ -n "$explicit_filename" ]; then
            base_filename="$explicit_filename"
            # Ensure .md extension
            [[ ! "$base_filename" =~ \.md$ ]] && base_filename="${base_filename}.md"
        else
            # Generate synthetic filename
            local timestamp_filename=$(date +%Y%m%d-%H%M%S)
            base_filename="stdin-${timestamp_filename}.md"
        fi
    else
        # Regular file mode - convert to absolute path for comparison
        if command -v realpath > /dev/null 2>&1; then
            input_file=$(realpath "$input_file")
        elif command -v readlink > /dev/null 2>&1; then
            input_file=$(readlink -f "$input_file" 2>/dev/null || echo "$input_file")
        fi
        base_filename=$(basename "$input_file")
    fi

    if [ "$stdin_mode" = true ]; then
        info_human "Creating comment from stdin as $base_filename..."
    else
        info_human "Creating comment from $original_file..."
    fi
    if [ "$JSON_MODE" = false ]; then
        echo ""
    fi

    # Determine reply-to URL from flag or positional arg or prompt
    local reply_to_url
    if [ -n "$explicit_reply_to" ]; then
        reply_to_url="$explicit_reply_to"
        log_default "Using reply-to URL from --reply-to flag: $reply_to_url"
    elif [ "$JSON_MODE" = true ]; then
        # In JSON mode, reply-to URL must be provided as second argument
        reply_to_url="$2"
        if [ -z "$reply_to_url" ]; then
            json_error "comment" "INVALID_INPUT" "Usage: polis --json comment <filename> <reply-to-url>"
        fi
        log_default "Using reply-to URL from argument: $reply_to_url"
    elif [ "$stdin_mode" = true ]; then
        # Stdin mode requires reply-to as second positional arg
        reply_to_url="$2"
        if [ -z "$reply_to_url" ]; then
            json_error "comment" "INVALID_INPUT" "Usage: polis comment - <reply-to-url> [--filename <name>] [--title <title>]"
        fi
        log_default "Using reply-to URL from argument: $reply_to_url"
    else
        # Regular file mode - check for positional arg first, then prompt
        reply_to_url="$2"
        if [ -z "$reply_to_url" ]; then
            # No argument provided, prompt interactively
            echo "Enter the URL of the post or comment you're replying to:"
            echo "(Example: https://alice.com/posts/20251229/hello-world.md)"
            read -r reply_to_url

            if [ -z "$reply_to_url" ]; then
                error "URL is required"
            fi
        fi
    fi

    if [ "$JSON_MODE" = false ]; then
        echo ""
    fi
    info_human "In reply to: $reply_to_url"

    # Determine root_post (always the original post, even if replying to a comment)
    local root_post
    if is_comment_url "$reply_to_url"; then
        # Replying to a comment - need to fetch the root post
        info_human "Detected reply to a comment. Fetching root post..."
        # Use || true to prevent set -e from killing script on failure
        root_post=$(fetch_root_post_for_comment "$reply_to_url") || true
        if [ -z "$root_post" ]; then
            # Fallback: can't determine root_post, this might fail at beseech time
            # but allow user to continue for now
            warn_human "Could not determine root post from discovery service."
            warn_human "Using immediate parent URL as root_post (may cause issues)."
            root_post="$reply_to_url"
        else
            info_human "Root post: $root_post"
        fi
    else
        # Replying directly to a post - root_post is the same as reply_to_url
        root_post="$reply_to_url"
    fi

    # Extract or use explicit title
    local title
    if [ -n "$explicit_title" ]; then
        title="$explicit_title"
    else
        title=$(extract_title "$input_file")
        # If stdin and title is temp filename fallback, use base_filename instead
        if [ "$stdin_mode" = true ] && [[ "$title" =~ ^tmp\. ]]; then
            # Convert filename to readable title
            title=$(echo "$base_filename" | sed 's/\.md$//' | sed 's/-/ /g' | \
                    awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
        fi
    fi
    info_human "Extracted title: $title"

    # Get current timestamp
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Read original content
    local content=$(cat "$input_file")

    # Hash the content
    local content_hash=$(hash_content "$input_file")
    local hash_short="${content_hash:0:6}-${content_hash: -6}"

    info_human "Content hash: sha256:$content_hash"
    info_human "Short hash: $hash_short"

    # Create date-stamped subdirectory in comments/
    local date_dir="$COMMENTS_DIR/$(date +%Y%m%d)"
    mkdir -p "$date_dir"

    # Note: base_filename is already set above in the stdin/file mode section

    # Create frontmatter (without signature first)
    local frontmatter_template="---
title: $title
type: comment
published: $timestamp
generator: polis-cli/$VERSION
in-reply-to:
  url: $reply_to_url
  root-post: $root_post
current-version: sha256:$content_hash
version-history:
  - sha256:$content_hash ($timestamp)
---"

    # Create temporary file with frontmatter + content (for signing)
    local temp_file=$(mktemp)
    echo "$frontmatter_template" > "$temp_file"
    echo "" >> "$temp_file"
    cat "$input_file" >> "$temp_file"

    # Sign the file
    info_human "Signing file..."
    local signature=$(sign_file "$temp_file")

    # Create final frontmatter with signature
    local frontmatter="---
title: $title
type: comment
published: $timestamp
generator: polis-cli/$VERSION
in-reply-to:
  url: $reply_to_url
  root-post: $root_post
current-version: sha256:$content_hash
version-history:
  - sha256:$content_hash ($timestamp)
signature: $signature
---"

    # Write canonical file
    local canonical_path="$date_dir/$base_filename"
    echo "$frontmatter" > "$canonical_path"
    echo "" >> "$canonical_path"
    cat "$input_file" >> "$canonical_path"
    success_human "Created canonical comment: $canonical_path"

    # Initialize version history with full content
    initialize_version_history "$canonical_path" "$content_hash" "$timestamp" "$content"
    local versions_file=$(get_versions_file_path "$canonical_path")
    success_human "Created versions file: $versions_file"

    # Clean up temp file
    rm -f "$temp_file"

    # Handle cleanup based on mode
    if [ "$stdin_mode" = true ]; then
        # Cleanup handled by trap - just inform user
        success_human "Created comment from stdin: $canonical_path"
    else
        # Remove original file if it's not already in the comments directory
        local canonical_abs=$(realpath "$canonical_path" 2>/dev/null || readlink -f "$canonical_path" 2>/dev/null || echo "$canonical_path")
        if [ "$input_file" != "$canonical_abs" ]; then
            rm -f "$original_file"
            success_human "Moved original file into comments/"
        fi
    fi

    # Append to public.jsonl index
    append_to_index "$canonical_path" "comment"

    # Request blessing from discovery service with comment
    if [ "$JSON_MODE" = false ]; then
        echo ""
    fi
    info_human "Automatically requesting blessing for comment..."
    _internal_beseech_from_file "$canonical_path"
    local beseech_status="pending"

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --arg path "$canonical_path" \
            --arg hash "sha256:$content_hash" \
            --arg reply_to "$reply_to_url" \
            --arg timestamp "$timestamp" \
            --arg status "$beseech_status" \
            '{
                file_path: $path,
                content_hash: $hash,
                in_reply_to: $reply_to,
                timestamp: $timestamp,
                beseech_status: $status
            }')
        json_success "comment" "$result"
    else
        echo ""
        success "Comment created!"
        echo ""
        info "Canonical: $canonical_path"
        info "Versions:  $versions_file"
    fi
}

# Command: polis preview <url>
# Preview content at a URL with signature verification
cmd_preview() {
    local content_url="$1"

    # Validate input
    if [ -z "$content_url" ]; then
        json_error "preview" "INVALID_INPUT" "Usage: polis preview <url>"
    fi

    # Validate URL format (must be HTTPS)
    if [[ ! "$content_url" =~ ^https:// ]]; then
        json_error "preview" "INVALID_INPUT" "URL must use HTTPS (e.g., https://example.com/posts/hello.md)"
    fi

    info_human "Fetching content from $content_url..."

    # Fetch content
    local content=$(fetch_remote_content "$content_url")

    if [ -z "$content" ]; then
        json_error "preview" "FETCH_ERROR" "Failed to fetch content from $content_url"
    fi

    # Check for frontmatter
    if ! echo "$content" | head -1 | grep -q '^---$'; then
        json_error "preview" "INVALID_CONTENT" "Content has no frontmatter (not a valid Polis post/comment)"
    fi

    # Auto-detect content type (post vs comment)
    local content_type="post"
    if echo "$content" | grep -q '^type: *comment'; then
        content_type="comment"
    elif echo "$content" | grep -q '^in-reply-to:'; then
        content_type="comment"
    fi

    info_human "Detected content type: $content_type"

    # Extract frontmatter fields
    local title=$(extract_frontmatter_field_from_content "$content" "title")
    local published=$(extract_frontmatter_field_from_content "$content" "published")
    local current_version=$(extract_frontmatter_field_from_content "$content" "current-version")
    local signature=$(extract_frontmatter_field_from_content "$content" "signature")
    local generator=$(extract_frontmatter_field_from_content "$content" "generator")

    # For comments, get in-reply-to URL
    local in_reply_to=""
    if [ "$content_type" = "comment" ]; then
        in_reply_to=$(echo "$content" | grep -A1 '^in-reply-to:' | grep 'url:' | sed 's/.*url: *//')
    fi

    # Extract base URL and fetch author info
    local base_url=$(extract_base_url "$content_url")
    info_human "Fetching author info from ${base_url}/.well-known/polis..."

    local public_key=$(fetch_remote_public_key "$base_url")
    local author_email=$(fetch_author_email_from_wellknown "$base_url" 2>/dev/null || echo "")

    # Signature verification
    local signature_status="unknown"
    local signature_message=""

    if [ -z "$public_key" ]; then
        signature_status="error"
        signature_message="Could not fetch public key from $base_url/.well-known/polis"
    elif [ -z "$signature" ]; then
        signature_status="missing"
        signature_message="Content has no signature"
    else
        # Verify signature
        if verify_remote_signature "$content" "$public_key" "$author_email"; then
            signature_status="valid"
            signature_message="Signature verified against author's public key"
        else
            signature_status="invalid"
            signature_message="SIGNATURE DOES NOT MATCH - content may have been tampered with"
        fi
    fi

    # Extract body content
    local body=$(extract_body_from_content "$content")

    # Verify content hash
    local hash_status="unknown"
    if [ -n "$current_version" ]; then
        local temp_body=$(mktemp)
        # Strip leading empty line (frontmatter adds blank line after closing ---)
        # The original file didn't have this leading newline
        echo "$body" | tail -n +2 > "$temp_body"
        local actual_hash=$(hash_content "$temp_body")
        rm -f "$temp_body"

        local expected_hash="${current_version#sha256:}"
        if [ "$actual_hash" = "$expected_hash" ]; then
            hash_status="valid"
        else
            hash_status="mismatch"
        fi
    fi

    # Collect validation issues
    local validation_issues="[]"
    local issues_array=()
    [ -z "$title" ] && issues_array+=("missing_title")
    [ -z "$published" ] && issues_array+=("missing_published")
    [ -z "$current_version" ] && issues_array+=("missing_current_version")
    [ -z "$signature" ] && issues_array+=("missing_signature")
    if [ "$content_type" = "comment" ] && [ -z "$in_reply_to" ]; then
        issues_array+=("missing_in_reply_to")
    fi
    if [ ${#issues_array[@]} -gt 0 ]; then
        validation_issues=$(printf '%s\n' "${issues_array[@]}" | jq -R . | jq -s .)
    fi

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --arg url "$content_url" \
            --arg type "$content_type" \
            --arg title "$title" \
            --arg published "$published" \
            --arg version "$current_version" \
            --arg generator "$generator" \
            --arg reply_to "$in_reply_to" \
            --arg author "$author_email" \
            --arg sig_status "$signature_status" \
            --arg sig_msg "$signature_message" \
            --arg hash_status "$hash_status" \
            --argjson issues "$validation_issues" \
            --arg body "$body" \
            '{
                url: $url,
                type: $type,
                title: $title,
                published: $published,
                current_version: $version,
                generator: $generator,
                in_reply_to: (if $reply_to == "" then null else $reply_to end),
                author: $author,
                signature: {
                    status: $sig_status,
                    message: $sig_msg
                },
                hash: {
                    status: $hash_status
                },
                validation_issues: $issues,
                body: $body
            }')
        json_success "preview" "$result"
    else
        # Human-readable output
        echo ""

        # Display frontmatter (dimmed)
        echo -e "${DIM}---${NC}"
        echo -e "${DIM}title: $title${NC}"
        echo -e "${DIM}type: $content_type${NC}"
        echo -e "${DIM}published: $published${NC}"
        echo -e "${DIM}current-version: $current_version${NC}"
        if [ -n "$generator" ]; then
            echo -e "${DIM}generator: $generator${NC}"
        fi
        if [ -n "$in_reply_to" ]; then
            echo -e "${DIM}in-reply-to: $in_reply_to${NC}"
        fi
        echo -e "${DIM}---${NC}"

        # Display body content
        echo "$body"

        # Light divider before verification (all dimmed)
        echo -e "${DIM}---${NC}"

        # Compact verification status (dimmed for valid, red for errors)
        case "$signature_status" in
            valid)
                echo -e "${GREEN}âœ“${DIM} Signature verified${NC}"
                ;;
            invalid)
                echo -e "${RED}âœ— Signature INVALID - content may have been tampered with${NC}"
                ;;
            missing)
                echo -e "${RED}âœ— Signature missing${NC}"
                ;;
            error)
                echo -e "${RED}! Could not verify signature${NC}"
                ;;
        esac

        case "$hash_status" in
            valid)
                echo -e "${GREEN}âœ“${DIM} Content hash verified${NC}"
                ;;
            mismatch)
                echo -e "${RED}âœ— Content hash MISMATCH - content may have been modified${NC}"
                ;;
            *)
                echo -e "${DIM}? Could not verify hash${NC}"
                ;;
        esac

        # Validation issues (if any)
        if [ "$validation_issues" != "[]" ]; then
            echo "$validation_issues" | jq -r '.[]' | while read issue; do
                echo -e "${RED}! $issue${NC}"
            done
        fi

        echo ""
    fi
}

# Command: polis republish <filename>
cmd_republish() {
    local input_file="$1"

    if [ -z "$input_file" ]; then
        json_error "republish" "INVALID_INPUT" "Usage: polis republish <filename>"
    fi

    if [ ! -f "$input_file" ]; then
        json_error "republish" "FILE_NOT_FOUND" "File not found: $input_file"
    fi

    if [ ! -f "$KEYS_DIR/id_ed25519" ]; then
        json_error "republish" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Check if file has frontmatter (already published)
    if ! has_frontmatter "$input_file"; then
        json_error "republish" "INVALID_STATE" "File not published yet (no frontmatter). Use 'polis publish' for new files."
    fi

    info_human "Republishing $input_file..."

    # Extract existing metadata
    local title=$(extract_frontmatter_field "$input_file" "title")
    local original_published=$(extract_frontmatter_field "$input_file" "published")
    local content_type=$(extract_frontmatter_field "$input_file" "type")

    if [ "$content_type" = "comment" ]; then
        info_human "Republishing comment: $title"
    else
        info_human "Republishing post: $title"
    fi

    # Get current timestamp for this version
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Get old hash (current version before update)
    local old_hash=$(extract_frontmatter_field "$input_file" "current-version")
    old_hash="${old_hash#sha256:}"

    # Extract NEW content without frontmatter (user has edited the file)
    local content_only=$(mktemp)
    extract_content_without_frontmatter "$input_file" > "$content_only"

    # Create temp file for old content (will be filled from .versions file)
    local old_content=$(mktemp)

    # Hash the new content
    local new_hash=$(hash_content "$content_only")
    local hash_short="${new_hash:0:6}-${new_hash: -6}"

    info_human "New content hash: sha256:$new_hash"
    info_human "Short hash: $hash_short"

    # Extract existing version history
    local version_history=$(extract_version_history "$input_file")

    # Extract in-reply-to section if this is a comment
    local in_reply_to=""
    if [ "$content_type" = "comment" ]; then
        in_reply_to=$(extract_in_reply_to "$input_file")
        if [ -z "$in_reply_to" ]; then
            error "Comment file missing in-reply-to section"
        fi
    fi

    # Get directory and filename
    local file_dir=$(dirname "$input_file")
    local base_filename=$(basename "$input_file")

    # Build new version history (old entries + new entry)
    # Only add newline separator if there are existing entries
    local version_history_new
    if [ -z "$version_history" ]; then
        version_history_new="  - sha256:$new_hash ($timestamp)"
    else
        version_history_new="$version_history"$'\n'"  - sha256:$new_hash ($timestamp)"
    fi

    # Create frontmatter (without signature first)
    # Different structure for comments vs posts
    local frontmatter_template
    if [ "$content_type" = "comment" ]; then
        frontmatter_template="---
title: $title
type: comment
published: $original_published
generator: polis-cli/$VERSION
in-reply-to:
$in_reply_to
current-version: sha256:$new_hash
version-history:
$version_history_new
---"
    else
        frontmatter_template="---
title: $title
published: $original_published
generator: polis-cli/$VERSION
current-version: sha256:$new_hash
version-history:
$version_history_new
---"
    fi

    # Create temporary file with frontmatter + content (for signing)
    local temp_file=$(mktemp)
    echo "$frontmatter_template" > "$temp_file"
    echo "" >> "$temp_file"
    cat "$content_only" >> "$temp_file"

    # Sign the file
    info "Signing file..."
    local signature=$(sign_file "$temp_file")

    # Create final frontmatter with signature
    # Different structure for comments vs posts
    local frontmatter
    if [ "$content_type" = "comment" ]; then
        frontmatter="---
title: $title
type: comment
published: $original_published
generator: polis-cli/$VERSION
in-reply-to:
$in_reply_to
current-version: sha256:$new_hash
version-history:
$version_history_new
signature: $signature
---"
    else
        frontmatter="---
title: $title
published: $original_published
generator: polis-cli/$VERSION
current-version: sha256:$new_hash
version-history:
$version_history_new
signature: $signature
---"
    fi

    # Generate diff before writing updated canonical
    local diff_content=""
    local versions_file=$(get_versions_file_path "$input_file")

    # Reconstruct old version from .versions file
    if [ -f "$versions_file" ]; then
        if reconstruct_version "$input_file" "sha256:$old_hash" "$old_content" 2>/dev/null; then
            diff_content=$(generate_version_diff "$content_only" "$old_content")
            info_human "Generated diff from sha256:${old_hash:0:13}... to sha256:${new_hash:0:13}..."
        else
            json_error "republish" "INVALID_STATE" "Failed to reconstruct version sha256:${old_hash:0:13}... from .versions file"
        fi
    else
        error "No .versions file found. This file may have been published with an older version of polis. Please run 'polis publish' on the original file again."
    fi

    # Write updated canonical file
    echo "$frontmatter" > "$input_file"
    echo "" >> "$input_file"
    cat "$content_only" >> "$input_file"
    success_human "Updated canonical file: $input_file"

    # Append diff to version history (if we generated one)
    if [ -n "$diff_content" ]; then
        append_version_to_history "$input_file" "$old_hash" "$new_hash" "$timestamp" "$diff_content"
        success_human "Added version sha256:${new_hash:0:13}... to .versions file"
    fi

    # Clean up temp files
    rm -f "$temp_file" "$content_only" "$old_content"

    # Rebuild public.json index
    rebuild_index

    # Request blessing from discovery service if this is a comment
    if [ "$content_type" = "comment" ]; then
        if [ "$JSON_MODE" = false ]; then
            echo ""
        fi
        info_human "Automatically requesting blessing for updated comment..."
        _internal_beseech_from_file "$input_file"
    fi

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --arg path "$input_file" \
            --arg old_hash "sha256:$old_hash" \
            --arg new_hash "sha256:$new_hash" \
            --arg timestamp "$timestamp" \
            --arg sig "$signature" \
            '{
                file_path: $path,
                previous_version: $old_hash,
                new_version: $new_hash,
                timestamp: $timestamp,
                signature: $sig
            }')
        json_success "republish" "$result"
    else
        echo ""
        success "Republishing complete!"
        echo ""
        info "Canonical: $input_file"
        if [ -f "$versions_file" ]; then
            info "Versions:  $versions_file"
        fi
    fi
}

# Command: polis rebuild
cmd_rebuild() {
    local do_content=false
    local do_comments=false

    # Parse flags (combinable)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --content)
                do_content=true
                shift
                ;;
            --comments)
                do_comments=true
                shift
                ;;
            --all)
                do_content=true
                do_comments=true
                shift
                ;;
            *)
                json_error "rebuild" "INVALID_INPUT" "Unknown option: $1. Use: polis rebuild --content|--comments|--all"
                ;;
        esac
    done

    # Require at least one target
    if [[ "$do_content" == false && "$do_comments" == false ]]; then
        json_error "rebuild" "INVALID_INPUT" "Must specify target: --content, --comments, or --all"
    fi

    local posts_count=0
    local comments_count=0
    local blessed_count=0

    # Rebuild content index
    if [[ "$do_content" == true ]]; then
        info_human "Rebuilding content index..."
        rebuild_index
        # Count entries
        if [ -f "$PUBLIC_INDEX" ]; then
            posts_count=$(grep -c '"type":"post"' "$PUBLIC_INDEX" 2>/dev/null || echo "0")
            comments_count=$(grep -c '"type":"comment"' "$PUBLIC_INDEX" 2>/dev/null || echo "0")
        fi
        success_human "Rebuilt public.jsonl ($posts_count posts, $comments_count comments)"
    fi

    # Rebuild blessed comments
    if [[ "$do_comments" == true ]]; then
        info_human "Rebuilding blessed comments..."
        rebuild_blessed_comments_full
        # Count blessed
        if [ -f "$BLESSED_COMMENTS" ]; then
            blessed_count=$(jq '.comments | length' "$BLESSED_COMMENTS" 2>/dev/null || echo "0")
        fi
        success_human "Rebuilt blessed-comments.json ($blessed_count blessed comments)"
    fi

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --argjson content "$do_content" \
            --argjson comments "$do_comments" \
            --argjson posts "$posts_count" \
            --argjson comments_indexed "$comments_count" \
            --argjson blessed "$blessed_count" \
            '{
                content_rebuilt: $content,
                comments_rebuilt: $comments,
                posts_indexed: $posts,
                comments_indexed: $comments_indexed,
                blessed_comments: $blessed
            }')
        json_success "rebuild" "$result"
    else
        success "Rebuild complete!"
    fi
}

# Command: polis index [--json]
# View the content index in JSONL or JSON format (read-only)
cmd_index() {
    local format="jsonl"  # default

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                format="json"
                shift
                ;;
            *)
                json_error "index" "INVALID_INPUT" "Unknown option: $1. Use: polis index [--json]"
                ;;
        esac
    done

    # Check if index exists
    if [ ! -f "$PUBLIC_INDEX" ]; then
        json_error "index" "FILE_NOT_FOUND" "Index file not found. Run 'polis rebuild' first."
    fi

    # Output based on format
    if [ "$format" = "json" ]; then
        # Convert JSONL to grouped JSON for readability
        jq -s --arg version "$VERSION" '{
            version: $version,
            posts: [.[] | select(.type == "post") | del(.type)],
            comments: [.[] | select(.type == "comment") | del(.type)]
        }' "$PUBLIC_INDEX"
    else
        # Output raw JSONL
        cat "$PUBLIC_INDEX"
    fi
}

# Command: polis version
# Print CLI version
cmd_version() {
    if [ "$JSON_MODE" = true ]; then
        jq -n --arg version "$VERSION" '{ status: "success", command: "version", data: { version: $version } }'
    else
        echo "polis $VERSION"
    fi
}

# Command: polis rotate-key [--delete-old-key]
# Generate new keypair and re-sign all posts and comments
cmd_rotate_key() {
    local delete_old=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --delete-old-key)
                delete_old=true
                shift
                ;;
            *)
                json_error "rotate-key" "INVALID_INPUT" "Unknown option: $1. Usage: polis rotate-key [--delete-old-key]"
                ;;
        esac
    done

    # Verify initialized
    if [ ! -f "$KEYS_DIR/id_ed25519" ]; then
        json_error "rotate-key" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "rotate-key" "INVALID_STATE" ".well-known/polis not found. Run 'polis init' first."
    fi

    info_human "Starting key rotation..."
    info_human ""

    # 1. Generate new keypair
    info_human "Generating new Ed25519 keypair..."
    ssh-keygen -t ed25519 -f "$KEYS_DIR/id_ed25519.new" -N "" -C "polis@$(hostname)" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        json_error "rotate-key" "KEY_GENERATION_FAILED" "Failed to generate new keypair"
    fi
    success_human "Generated new keypair"

    # 2. Backup old key
    mv "$KEYS_DIR/id_ed25519" "$KEYS_DIR/id_ed25519.old"
    mv "$KEYS_DIR/id_ed25519.pub" "$KEYS_DIR/id_ed25519.old.pub"

    # 3. Install new key
    mv "$KEYS_DIR/id_ed25519.new" "$KEYS_DIR/id_ed25519"
    mv "$KEYS_DIR/id_ed25519.new.pub" "$KEYS_DIR/id_ed25519.pub"
    success_human "Installed new keypair"

    # 4. Re-sign all posts
    local posts_count=0
    local posts_failed=0
    info_human ""
    info_human "Re-signing posts..."

    if [ -d "$POSTS_DIR" ]; then
        while IFS= read -r -d '' file; do
            if resign_file "$file"; then
                ((posts_count++))
            else
                ((posts_failed++))
                warn_human "  Failed to re-sign: $file"
            fi
        done < <(find "$POSTS_DIR" -name "*.md" -type f -print0 2>/dev/null)
    fi
    success_human "Re-signed $posts_count posts"

    # 5. Re-sign all comments
    local comments_count=0
    local comments_failed=0
    info_human ""
    info_human "Re-signing comments..."

    if [ -d "$COMMENTS_DIR" ]; then
        while IFS= read -r -d '' file; do
            if resign_file "$file"; then
                ((comments_count++))
            else
                ((comments_failed++))
                warn_human "  Failed to re-sign: $file"
            fi
        done < <(find "$COMMENTS_DIR" -name "*.md" -type f -print0 2>/dev/null)
    fi
    success_human "Re-signed $comments_count comments"

    # 6. Update .well-known/polis
    info_human ""
    info_human "Updating .well-known/polis..."
    if update_wellknown_pubkey; then
        success_human "Updated public key in .well-known/polis"
    else
        warn_human "Failed to update .well-known/polis"
    fi

    # 7. Rebuild index
    info_human ""
    info_human "Rebuilding index..."
    cmd_rebuild --content > /dev/null 2>&1
    success_human "Rebuilt public.jsonl index"

    # 8. Handle old key
    local old_key_status
    if [ "$delete_old" = true ]; then
        rm -f "$KEYS_DIR/id_ed25519.old" "$KEYS_DIR/id_ed25519.old.pub"
        old_key_status="deleted"
        info_human ""
        info_human "Deleted old keypair"
    else
        old_key_status="archived"
        info_human ""
        info_human "Old keypair archived at $KEYS_DIR/id_ed25519.old"
    fi

    # Get new key fingerprint
    local new_fingerprint=$(ssh-keygen -lf "$KEYS_DIR/id_ed25519.pub" 2>/dev/null | awk '{print $2}')

    # Output results
    info_human ""
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --argjson posts "$posts_count" \
            --argjson posts_failed "$posts_failed" \
            --argjson comments "$comments_count" \
            --argjson comments_failed "$comments_failed" \
            --arg old_key_status "$old_key_status" \
            --arg fingerprint "$new_fingerprint" \
            '{
                posts_resigned: $posts,
                posts_failed: $posts_failed,
                comments_resigned: $comments,
                comments_failed: $comments_failed,
                old_key: $old_key_status,
                new_key_fingerprint: $fingerprint
            }')
        json_success "rotate-key" "$result"
    else
        success "Key rotation complete!"
        info "  Posts re-signed: $posts_count"
        info "  Comments re-signed: $comments_count"
        info "  New key fingerprint: $new_fingerprint"
        if [ "$old_key_status" = "archived" ]; then
            info "  Old key: archived at $KEYS_DIR/id_ed25519.old"
        else
            info "  Old key: deleted"
        fi
    fi
}

# Command: polis get-version <file> <hash>
cmd_get_version() {
    local file="$1"
    local target_hash="$2"

    if [ -z "$file" ] || [ -z "$target_hash" ]; then
        error "Usage: polis get-version <file> <hash>"
    fi

    if [ ! -f "$file" ]; then
        error "File not found: $file"
    fi

    # Ensure hash has sha256: prefix
    if [[ ! "$target_hash" =~ ^sha256: ]]; then
        target_hash="sha256:$target_hash"
    fi

    info "Reconstructing version $target_hash..."

    # Create temporary output file
    local output=$(mktemp)

    # Reconstruct the version
    reconstruct_version "$file" "$target_hash" "$output"

    # Output to stdout
    cat "$output"

    # Clean up
    rm -f "$output"
}

# ============================================================================
# BLESSING COMMANDS
# ============================================================================

# Command: polis blessing requests
cmd_blessing_requests() {
    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "blessing-requests" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Sync blessed comments first (catches auto-blessed comments from server)
    if [ -n "$POLIS_BASE_URL" ]; then
        local synced=$(sync_blessed_comments)
        if [ "$synced" -gt 0 ]; then
            info_human "Synced $synced auto-blessed comment(s) to blessed-comments.json"
        fi
    fi

    # Extract author and domain
    local author=$(extract_author_from_wellknown)
    local domain=$(extract_domain_from_url "$POLIS_BASE_URL")

    # Construct endpoint URL
    local endpoint="${POLIS_BLESSING_REQUESTS_ENDPOINT}"

    info_human "Fetching pending blessing requests for ${author} from ${endpoint} ..."

    # Fetch requests
    local response=$(curl -s \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        "${endpoint}?in_reply_to_domain=${domain}")

    if [ $? -ne 0 ]; then
        json_error "blessing-requests" "API_ERROR" "Failed to connect to discovery service. Check your internet connection and POLIS_BESEECH_ENDPOINT."
    fi

    # Check if jq is available
    if ! command -v jq > /dev/null 2>&1; then
        json_error "blessing-requests" "MISSING_DEPENDENCY" "jq is required but not installed. Please install jq to continue."
    fi

    # Check for API errors
    local error_msg=$(echo "$response" | jq -r '.error // empty' 2>/dev/null)
    if [ -n "$error_msg" ]; then
        json_error "blessing-requests" "API_ERROR" "API error: $error_msg"
    fi

    # In JSON mode, return the API response directly
    if [ "$JSON_MODE" = true ]; then
        # Extract requests array and count
        local requests=$(echo "$response" | jq -c '.requests // []')
        local count=$(echo "$response" | jq -r '.count // 0')

        local result=$(jq -n \
            --argjson count "$count" \
            --argjson requests "$requests" \
            '{
                count: $count,
                requests: $requests
            }')
        json_success "blessing-requests" "$result"
    else
        # Format and display table
        format_blessing_table "$response"
    fi
}

# Command: polis blessing grant <hash>
cmd_blessing_grant() {
    local input_hash="$1"

    # Validate arguments
    if [ -z "$input_hash" ]; then
        json_error "blessing-grant" "INVALID_INPUT" "Usage: polis blessing grant <hash>"
    fi

    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "blessing-grant" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Check POLIS_BASE_URL is set (needed for domain extraction)
    if [ -z "$POLIS_BASE_URL" ]; then
        json_error "blessing-grant" "INVALID_STATE" "POLIS_BASE_URL not set. Export it first."
    fi

    # Resolve short hash to full comment_version
    info_human "Resolving hash..."
    local domain=$(echo "$POLIS_BASE_URL" | sed 's|https\?://||' | sed 's|/.*||')
    local comment_version

    # Check if input is already a full hash (starts with sha256:)
    if [[ "$input_hash" == sha256:* ]]; then
        comment_version="$input_hash"
    else
        comment_version=$(resolve_short_hash "$input_hash" "$domain")
    fi

    if [ -z "$comment_version" ]; then
        json_error "blessing-grant" "NOT_FOUND" "No pending request found matching hash: $input_hash"
    fi

    local short_hash=$(format_short_hash "$comment_version")

    # Fetch request details
    info_human "Fetching request details..."
    local request_json=$(fetch_request_details "$comment_version")

    if [ -z "$request_json" ] || [ "$request_json" = "null" ]; then
        json_error "blessing-grant" "NOT_FOUND" "Request $short_hash not found"
    fi

    # Display request details in human mode
    if [ "$JSON_MODE" = false ]; then
        display_request_details "$short_hash" "$request_json"
    fi

    # Validate comment URL is reachable before blessing
    local comment_url=$(echo "$request_json" | jq -r '.comment_url')
    if [ -n "$comment_url" ] && [ "$comment_url" != "null" ]; then
        local url_status=$(curl -s -o /dev/null -w "%{http_code}" "$comment_url")
        if [ "$url_status" = "404" ]; then
            json_error "blessing-grant" "COMMENT_NOT_FOUND" "Comment URL returns 404. The comment may have been deleted: $comment_url"
        elif [ "$url_status" != "200" ]; then
            warn_human "Warning: Comment URL returned HTTP $url_status (expected 200)"
        fi
    fi

    # Create signed payload for authentication
    # The signature proves the requester controls the post author's domain
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local canonical_payload=$(jq -n -c \
        --arg action "grant" \
        --arg version "$comment_version" \
        --arg ts "$timestamp" \
        '{action: $action, comment_version: $version, timestamp: $ts}')

    # Sign the payload
    local temp_file=$(mktemp)
    echo -n "$canonical_payload" > "$temp_file"
    local keyfile="$KEYS_DIR/id_ed25519"
    ssh-keygen -Y sign -f "$keyfile" -n file "$temp_file" > /dev/null 2>&1
    local signature=$(cat "$temp_file.sig")
    rm -f "$temp_file" "$temp_file.sig"

    # Prepare POST payload with signature
    local payload=$(jq -n \
        --arg version "$comment_version" \
        --arg action "grant" \
        --arg ts "$timestamp" \
        --arg sig "$signature" \
        '{comment_version: $version, action: $action, timestamp: $ts, signature: $sig}')

    # Call bless endpoint
    local response=$(curl -s -w "\n%{http_code}" \
        --location --request POST "$POLIS_BLESS_ENDPOINT" \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        --header 'Content-Type: application/json' \
        --data "$payload")

    # Extract HTTP status code
    local http_code=$(echo "$response" | tail -n 1)
    local body=$(echo "$response" | sed '$d')

    # Handle response
    case "$http_code" in
        200)
            # Extract comment details from response
            local comment_url=$(echo "$body" | jq -r '.request.comment_url')
            local resp_version=$(echo "$body" | jq -r '.request.comment_version')
            local in_reply_to=$(echo "$body" | jq -r '.request.in_reply_to')
            local blessed_at=$(echo "$body" | jq -r '.request.blessed_at')
            local author=$(echo "$body" | jq -r '.request.author')

            # Update blessed-comments.json
            update_blessed_comments_json "$comment_url" "$resp_version" "$in_reply_to" "$blessed_at"

            # Extract blessed_by from server response (server determines this from verified domain)
            local blessed_by=$(echo "$body" | jq -r '.request.blessed_by // empty')

            if [ "$JSON_MODE" = true ]; then
                local result=$(jq -n \
                    --arg version "$comment_version" \
                    --arg url "$comment_url" \
                    --arg blessed_at "$blessed_at" \
                    --arg blessed_by "$blessed_by" \
                    '{
                        comment_version: $version,
                        comment_url: $url,
                        blessed_at: $blessed_at,
                        blessed_by: $blessed_by
                    }')
                json_success "blessing-grant" "$result"
            else
                success "Blessing granted for request $short_hash"
                success "Updated blessed-comments.json"
                info "Comment from $author is now blessed"
            fi
            ;;
        403)
            json_error "blessing-grant" "PERMISSION_ERROR" "Signature verification failed: You can only bless comments on your own posts. Response: $body"
            ;;
        404)
            json_error "blessing-grant" "INVALID_INPUT" "Request $short_hash not found. Response: $body"
            ;;
        400)
            json_error "blessing-grant" "INVALID_INPUT" "Invalid request. Response: $body"
            ;;
        *)
            json_error "blessing-grant" "API_ERROR" "Failed to grant blessing (HTTP $http_code). Response: $body"
            ;;
    esac
}

# Command: polis blessing deny <hash>
cmd_blessing_deny() {
    local input_hash="$1"

    # Validate arguments
    if [ -z "$input_hash" ]; then
        json_error "blessing-deny" "INVALID_INPUT" "Usage: polis blessing deny <hash>"
    fi

    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "blessing-deny" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Check POLIS_BASE_URL is set (needed for domain extraction)
    if [ -z "$POLIS_BASE_URL" ]; then
        json_error "blessing-deny" "INVALID_STATE" "POLIS_BASE_URL not set. Export it first."
    fi

    # Resolve short hash to full comment_version
    info_human "Resolving hash..."
    local domain=$(echo "$POLIS_BASE_URL" | sed 's|https\?://||' | sed 's|/.*||')
    local comment_version

    # Check if input is already a full hash (starts with sha256:)
    if [[ "$input_hash" == sha256:* ]]; then
        comment_version="$input_hash"
    else
        comment_version=$(resolve_short_hash "$input_hash" "$domain")
    fi

    if [ -z "$comment_version" ]; then
        json_error "blessing-deny" "NOT_FOUND" "No pending request found matching hash: $input_hash"
    fi

    local short_hash=$(format_short_hash "$comment_version")

    # Fetch request details
    info_human "Fetching request details..."
    local request_json=$(fetch_request_details "$comment_version")

    if [ -z "$request_json" ] || [ "$request_json" = "null" ]; then
        json_error "blessing-deny" "NOT_FOUND" "Request $short_hash not found"
    fi

    # Display request details in human mode
    if [ "$JSON_MODE" = false ]; then
        display_request_details "$short_hash" "$request_json"
    fi

    # Check if comment URL is reachable (warn only, don't block deny)
    local comment_url=$(echo "$request_json" | jq -r '.comment_url')
    if [ -n "$comment_url" ] && [ "$comment_url" != "null" ]; then
        local url_status=$(curl -s -o /dev/null -w "%{http_code}" "$comment_url")
        if [ "$url_status" = "404" ]; then
            warn_human "Note: Comment URL returns 404 (may have been deleted)"
        fi
    fi

    # Create signed payload for authentication
    # The signature proves the requester controls the post author's domain
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local canonical_payload=$(jq -n -c \
        --arg action "deny" \
        --arg version "$comment_version" \
        --arg ts "$timestamp" \
        '{action: $action, comment_version: $version, timestamp: $ts}')

    # Sign the payload
    local temp_file=$(mktemp)
    echo -n "$canonical_payload" > "$temp_file"
    local keyfile="$KEYS_DIR/id_ed25519"
    ssh-keygen -Y sign -f "$keyfile" -n file "$temp_file" > /dev/null 2>&1
    local signature=$(cat "$temp_file.sig")
    rm -f "$temp_file" "$temp_file.sig"

    # Prepare POST payload with signature
    local payload=$(jq -n \
        --arg version "$comment_version" \
        --arg action "deny" \
        --arg ts "$timestamp" \
        --arg sig "$signature" \
        '{comment_version: $version, action: $action, timestamp: $ts, signature: $sig}')

    # Call deny endpoint
    local response=$(curl -s -w "\n%{http_code}" \
        --location --request POST "$POLIS_DENY_ENDPOINT" \
        --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
        --header 'Content-Type: application/json' \
        --data "$payload")

    # Extract HTTP status code
    local http_code=$(echo "$response" | tail -n 1)
    local body=$(echo "$response" | sed '$d')

    # Handle response
    case "$http_code" in
        200)
            # Extract comment details from response
            local comment_url=$(echo "$body" | jq -r '.request.comment_url')
            local in_reply_to=$(echo "$body" | jq -r '.request.in_reply_to')
            local denied_at=$(echo "$body" | jq -r '.request.denied_at // .request.blessed_at // ""')
            local author=$(echo "$body" | jq -r '.request.author')

            # Remove from blessed-comments.json if it was previously blessed
            remove_from_blessed_comments_json "$comment_url" "$in_reply_to"

            # Extract denied_by from server response (server determines this from verified domain)
            local denied_by=$(echo "$body" | jq -r '.request.blessed_by // empty')

            if [ "$JSON_MODE" = true ]; then
                local result=$(jq -n \
                    --arg version "$comment_version" \
                    --arg url "$comment_url" \
                    --arg denied_at "$denied_at" \
                    --arg denied_by "$denied_by" \
                    '{
                        comment_version: $version,
                        comment_url: $url,
                        denied_at: $denied_at,
                        denied_by: $denied_by
                    }')
                json_success "blessing-deny" "$result"
            else
                success "Blessing denied for request $short_hash"
                info "Removed from blessed-comments.json (if present)"
                info "Comment from $author has been denied"
            fi
            ;;
        403)
            json_error "blessing-deny" "PERMISSION_ERROR" "Signature verification failed: You can only deny comments on your own posts. Response: $body"
            ;;
        404)
            json_error "blessing-deny" "INVALID_INPUT" "Request $short_hash not found. Response: $body"
            ;;
        400)
            json_error "blessing-deny" "INVALID_INPUT" "Invalid request. Response: $body"
            ;;
        *)
            json_error "blessing-deny" "API_ERROR" "Failed to deny blessing (HTTP $http_code). Response: $body"
            ;;
    esac
}

# Command: polis blessing sync
# Synchronize blessed comments from discovery service to local blessed-comments.json
cmd_blessing_sync() {
    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "blessing-sync" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Check POLIS_BASE_URL is set
    if [ -z "$POLIS_BASE_URL" ]; then
        json_error "blessing-sync" "INVALID_STATE" "POLIS_BASE_URL not set. Export it first: export POLIS_BASE_URL=https://yourdomain.com"
    fi

    info_human "Syncing blessed comments from discovery service..."

    local synced=$(sync_blessed_comments)

    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --argjson synced_count "$synced" \
            '{synced_count: $synced_count}')
        json_success "blessing-sync" "$result"
    else
        if [ "$synced" -gt 0 ]; then
            success "Synced $synced comment(s) to blessed-comments.json"
        else
            info "Already in sync - no new comments to add"
        fi
    fi
}

# Command: polis follow <author-url>
cmd_follow() {
    local author_url="$1"

    # Validate author_url
    if [ -z "$author_url" ]; then
        json_error "follow" "INVALID_INPUT" "Usage: polis follow <author-url>"
    fi

    # Validate URL format (must be HTTPS)
    if [[ ! "$author_url" =~ ^https:// ]]; then
        json_error "follow" "INVALID_INPUT" "Author URL must use HTTPS (e.g., https://example.com)"
    fi

    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "follow" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Extract blessed_by (current user's email)
    local blessed_by=$(extract_author_from_wellknown)

    # Fetch author email from their .well-known/polis
    info_human "Fetching author information from $author_url..."
    local author_email=$(fetch_author_email_from_wellknown "$author_url")

    if [ -z "$author_email" ]; then
        json_error "follow" "API_ERROR" "Failed to fetch author email from $author_url"
    fi

    info_human "Author email: $author_email"

    # Fetch unblessed comments from this author
    info_human "Fetching comments from $author_email..."
    local pending_comments=$(fetch_comments_by_author "$author_email" "pending")
    local denied_comments=$(fetch_comments_by_author "$author_email" "denied")

    # Combine pending and denied into one array
    local unblessed_comments=$(jq -s 'add' <(echo "$pending_comments") <(echo "$denied_comments"))
    local comment_count=$(echo "$unblessed_comments" | jq 'length')

    # Display summary in human mode
    if [ "$JSON_MODE" = false ]; then
        echo ""
        info "Following: $author_url ($author_email)"

        if [ "$comment_count" -gt 0 ]; then
            echo "Found $comment_count unblessed comment(s) from this author on your posts:"
            echo ""

            # Show first 5 comments as preview
            local preview_count=$comment_count
            if [ "$comment_count" -gt 5 ]; then
                preview_count=5
            fi

            echo "$unblessed_comments" | jq -r --arg count "$preview_count" \
                'limit($count | tonumber; .[]) | "  - Request #\(.id): \(.comment_url | split("/")[-1]) (\(.timestamp[:10]))"'

            if [ "$comment_count" -gt 5 ]; then
                echo "  ... and $((comment_count - 5)) more"
            fi

            echo ""
            echo "All these comments will be blessed."
        else
            echo "No unblessed comments found from this author."
            echo "Future comments from this author will be automatically blessed."
        fi
        echo ""
    fi

    # Bless all unblessed comments
    local blessed_count=0
    local failed_count=0

    if [ "$comment_count" -gt 0 ]; then
        info_human "Blessing $comment_count comment(s)..."

        # Loop through each comment
        while IFS= read -r comment_id; do
            if [ -z "$comment_id" ] || [ "$comment_id" = "null" ]; then
                continue
            fi

            # Prepare POST payload
            local payload=$(jq -n \
                --argjson id "$comment_id" \
                --arg by "$blessed_by" \
                '{comment_id: $id, blessed_by: $by}')

            # Call bless endpoint
            local response=$(curl -s -w "\n%{http_code}" \
                --location --request POST "$POLIS_BLESS_ENDPOINT" \
                --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
                --header 'Content-Type: application/json' \
                --data "$payload")

            # Extract HTTP status code
            local http_code=$(echo "$response" | tail -n 1)
            local body=$(echo "$response" | sed '$d')

            # Handle response
            if [ "$http_code" = "200" ]; then
                # Extract comment details from response
                local comment_url=$(echo "$body" | jq -r '.request.comment_url')
                local comment_version=$(echo "$body" | jq -r '.request.comment_version')
                local in_reply_to=$(echo "$body" | jq -r '.request.in_reply_to')
                local blessed_at=$(echo "$body" | jq -r '.request.blessed_at')

                # Update blessed-comments.json
                update_blessed_comments_json "$comment_url" "$comment_version" "$in_reply_to" "$blessed_at"

                blessed_count=$((blessed_count + 1))
            else
                failed_count=$((failed_count + 1))
                info_human "Warning: Failed to bless request #$comment_id (HTTP $http_code)"
            fi
        done < <(echo "$unblessed_comments" | jq -r '.[].id')
    fi

    # Add to following.json
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    add_to_following_json "$author_url" "$timestamp"

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --arg url "$author_url" \
            --arg email "$author_email" \
            --argjson found "$comment_count" \
            --argjson blessed "$blessed_count" \
            '{
                author_url: $url,
                author_email: $email,
                comments_found: $found,
                comments_blessed: $blessed,
                added_to_following: true
            }')
        json_success "follow" "$result"
    else
        # Display success summary
        echo ""
        success "Successfully followed $author_url"
        echo "  - Added to following.json"

        if [ "$comment_count" -gt 0 ]; then
            if [ "$failed_count" -eq 0 ]; then
                echo "  - Blessed $blessed_count comment(s)"
            else
                echo "  - Blessed $blessed_count/$comment_count comment(s) ($failed_count failed)"
            fi
        fi
    fi
}

# Command: polis unfollow <author-url>
cmd_unfollow() {
    local author_url="$1"

    # Validate author_url
    if [ -z "$author_url" ]; then
        json_error "unfollow" "INVALID_INPUT" "Usage: polis unfollow <author-url>"
    fi

    # Validate URL format (must be HTTPS)
    if [[ ! "$author_url" =~ ^https:// ]]; then
        json_error "unfollow" "INVALID_INPUT" "Author URL must use HTTPS (e.g., https://example.com)"
    fi

    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "unfollow" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Extract blessed_by (current user's email)
    local blessed_by=$(extract_author_from_wellknown)

    # Get blessed comment URLs from this author
    # Check both local blessed-comments.json AND server (for unsynced auto-blessed)
    info_human "Finding blessed comments from $author_url..."

    # 1. Get local blessed URLs
    local local_blessed_urls=$(get_blessed_comment_urls_by_author "$author_url")
    local local_urls_list=$(echo "$local_blessed_urls" | jq -r '.[]' 2>/dev/null || echo "")

    # 2. Also fetch from server (catches unsynced auto-blessed comments)
    local author_email=""
    local server_urls_list=""
    author_email=$(fetch_author_email_from_wellknown "$author_url" 2>/dev/null) || true

    if [ -n "$author_email" ]; then
        local server_blessed=$(fetch_comments_by_author "$author_email" "blessed" 2>/dev/null) || true
        if [ -n "$server_blessed" ] && [ "$server_blessed" != "[]" ] && [ "$server_blessed" != "null" ]; then
            server_urls_list=$(echo "$server_blessed" | jq -r '.[].comment_url' 2>/dev/null || echo "")
        fi
    fi

    # 3. Combine and deduplicate URLs
    local all_urls_list=$(echo -e "$local_urls_list\n$server_urls_list" | sort -u | grep -v '^$')
    local blessed_urls=$(echo "$all_urls_list" | jq -R . | jq -s .)
    local url_count=$(echo "$blessed_urls" | jq 'length')

    if [ "$url_count" -eq 0 ]; then
        remove_from_following_json "$author_url"

        if [ "$JSON_MODE" = true ]; then
            local result=$(jq -n \
                --arg url "$author_url" \
                '{
                    author_url: $url,
                    comments_found: 0,
                    comments_denied: 0,
                    removed_from_following: true
                }')
            json_success "unfollow" "$result"
        else
            info "No blessed comments found from this author"
            success "Successfully unfollowed $author_url"
        fi
        exit 0
    fi

    info_human "Found $url_count blessed comment(s), looking up IDs..."

    # Lookup comment ID for each blessed comment URL
    local comment_ids=()
    local lookup_failures=0

    while IFS= read -r comment_url; do
        if [ -z "$comment_url" ] || [ "$comment_url" = "null" ]; then
            continue
        fi

        local comment_id=$(get_comment_id_by_url "$comment_url")
        if [ -n "$comment_id" ] && [ "$comment_id" != "null" ]; then
            comment_ids+=("$comment_id")
        else
            lookup_failures=$((lookup_failures + 1))
            info_human "Warning: Could not find ID for $comment_url"
        fi
    done < <(echo "$blessed_urls" | jq -r '.[]')

    local comment_count=${#comment_ids[@]}

    # Display summary in human mode
    if [ "$JSON_MODE" = false ]; then
        echo ""
        info "Unfollowing: $author_url"
        echo "Found $comment_count blessed comment(s) to deny"
        if [ $lookup_failures -gt 0 ]; then
            echo "Warning: $lookup_failures comment(s) could not be looked up"
        fi
        echo ""
    fi

    # Deny each comment
    local denied_count=0
    local failed_count=0

    if [ $comment_count -gt 0 ]; then
        info_human "Denying $comment_count blessed comment(s)..."

        for comment_id in "${comment_ids[@]}"; do
            # Prepare POST payload
            local payload=$(jq -n \
                --argjson id "$comment_id" \
                --arg by "$blessed_by" \
                '{comment_id: $id, blessed_by: $by}')

            # Call deny endpoint
            local response=$(curl -s -w "\n%{http_code}" \
                --location --request POST "$POLIS_DENY_ENDPOINT" \
                --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
                --header 'Content-Type: application/json' \
                --data "$payload")

            local http_code=$(echo "$response" | tail -n 1)
            local body=$(echo "$response" | sed '$d')

            if [ "$http_code" = "200" ]; then
                local comment_url=$(echo "$body" | jq -r '.request.comment_url')
                local in_reply_to=$(echo "$body" | jq -r '.request.in_reply_to')

                # Remove from blessed-comments.json
                remove_from_blessed_comments_json "$comment_url" "$in_reply_to"

                denied_count=$((denied_count + 1))
            else
                failed_count=$((failed_count + 1))
                info_human "Warning: Failed to deny comment #$comment_id (HTTP $http_code)"
            fi
        done
    fi

    # Remove from following.json
    remove_from_following_json "$author_url"

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --arg url "$author_url" \
            --argjson found "$url_count" \
            --argjson denied "$denied_count" \
            '{
                author_url: $url,
                comments_found: $found,
                comments_denied: $denied,
                removed_from_following: true
            }')
        json_success "unfollow" "$result"
    else
        # Display success summary
        echo ""
        success "Successfully unfollowed $author_url"
        echo "  - Removed from following.json"

        if [ $comment_count -gt 0 ]; then
            if [ $failed_count -eq 0 ]; then
                echo "  - Denied $denied_count blessed comment(s)"
            else
                echo "  - Denied $denied_count/$comment_count comment(s) ($failed_count failed)"
            fi
        fi
    fi
}

# Command: polis blessing <subcommand>
cmd_blessing() {
    local subcommand="$1"
    shift

    case "$subcommand" in
        requests)
            cmd_blessing_requests "$@"
            ;;
        grant)
            cmd_blessing_grant "$@"
            ;;
        deny)
            cmd_blessing_deny "$@"
            ;;
        beseech)
            cmd_blessing_beseech "$@"
            ;;
        sync)
            cmd_blessing_sync "$@"
            ;;
        *)
            error "Unknown blessing subcommand: $subcommand

Usage: polis blessing requests
       polis blessing grant <request-id>
       polis blessing deny <request-id>
       polis blessing beseech <request-id>
       polis blessing sync"
            ;;
    esac
}

# Command: polis publish <filename>
cmd_publish() {
    # Parse command-specific flags first
    local explicit_filename=""
    local explicit_title=""
    local positional_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            --filename)
                explicit_filename="$2"
                shift 2
                ;;
            --title)
                explicit_title="$2"
                shift 2
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    # Restore positional arguments
    set -- "${positional_args[@]}"

    local input_file="$1"

    if [ -z "$input_file" ]; then
        json_error "publish" "INVALID_INPUT" "Usage: polis publish <filename>\n       polis publish - [--filename <name>] [--title <title>]"
    fi

    if [ ! -f "$KEYS_DIR/id_ed25519" ]; then
        json_error "publish" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Check for stdin mode
    local stdin_mode=false
    local temp_stdin=""

    if [ "$input_file" = "-" ]; then
        stdin_mode=true

        # Verify stdin is not a terminal (has actual content)
        if [ -t 0 ]; then
            json_error "publish" "INVALID_INPUT" "No stdin content. Use: echo 'content' | polis publish -"
        fi

        # Create temp file and read stdin
        temp_stdin=$(mktemp)
        cat > "$temp_stdin"

        # Verify content
        if [ ! -s "$temp_stdin" ]; then
            rm -f "$temp_stdin"
            json_error "publish" "INVALID_INPUT" "Stdin content is empty"
        fi

        # Point input_file to temp file
        input_file="$temp_stdin"

        info_human "Reading content from stdin..."
    else
        # Regular file mode - check file exists
        if [ ! -f "$input_file" ]; then
            json_error "publish" "FILE_NOT_FOUND" "File not found: $input_file"
        fi
    fi

    # Ensure temp file cleanup on exit or error
    cleanup_stdin() {
        if [ -n "$temp_stdin" ] && [ -f "$temp_stdin" ]; then
            rm -f "$temp_stdin"
        fi
    }
    trap cleanup_stdin EXIT ERR

    # Check if file already has frontmatter (already published)
    # Skip this check for stdin mode as stdin content is always new
    if [ "$stdin_mode" = false ] && has_frontmatter "$input_file"; then
        json_error "publish" "INVALID_STATE" "File already published (has frontmatter). Use 'polis republish' to update it."
    fi

    # Store original file path for cleanup later
    local original_file="$input_file"

    # Determine base filename
    local base_filename
    if [ "$stdin_mode" = true ]; then
        if [ -n "$explicit_filename" ]; then
            base_filename="$explicit_filename"
            # Ensure .md extension
            [[ ! "$base_filename" =~ \.md$ ]] && base_filename="${base_filename}.md"
        else
            # Generate synthetic filename
            local timestamp_filename=$(date +%Y%m%d-%H%M%S)
            base_filename="stdin-${timestamp_filename}.md"
        fi
    else
        # Regular file mode - convert to absolute path for comparison
        if command -v realpath > /dev/null 2>&1; then
            input_file=$(realpath "$input_file")
        elif command -v readlink > /dev/null 2>&1; then
            input_file=$(readlink -f "$input_file" 2>/dev/null || echo "$input_file")
        fi
        base_filename=$(basename "$input_file")
    fi

    if [ "$stdin_mode" = true ]; then
        info_human "Publishing from stdin as $base_filename..."
    else
        info_human "Publishing $original_file..."
    fi

    # Extract or use explicit title
    local title
    if [ -n "$explicit_title" ]; then
        title="$explicit_title"
    else
        title=$(extract_title "$input_file")
        # If stdin and title is temp filename fallback, use base_filename instead
        if [ "$stdin_mode" = true ] && [[ "$title" =~ ^tmp\. ]]; then
            # Convert filename to readable title
            title=$(echo "$base_filename" | sed 's/\.md$//' | sed 's/-/ /g' | \
                    awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
        fi
    fi
    info_human "Extracted title: $title"

    # Get current timestamp
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Read original content
    local content=$(cat "$input_file")

    # Hash the content
    local content_hash=$(hash_content "$input_file")
    local hash_short="${content_hash:0:6}-${content_hash: -6}"

    info_human "Content hash: sha256:$content_hash"
    info_human "Short hash: $hash_short"

    # Create date-stamped subdirectory
    local date_dir="$POSTS_DIR/$(date +%Y%m%d)"
    mkdir -p "$date_dir"

    # Note: base_filename is already set above in the stdin/file mode section

    # Create frontmatter (without signature first)
    local frontmatter_template="---
title: $title
published: $timestamp
generator: polis-cli/$VERSION
current-version: sha256:$content_hash
version-history:
  - sha256:$content_hash ($timestamp)
---"

    # Create temporary file with frontmatter + content (for signing)
    local temp_file=$(mktemp)
    echo "$frontmatter_template" > "$temp_file"
    echo "" >> "$temp_file"
    cat "$input_file" >> "$temp_file"

    # Sign the file
    info_human "Signing file..."
    local signature=$(sign_file "$temp_file")

    # Create final frontmatter with signature
    local frontmatter="---
title: $title
published: $timestamp
generator: polis-cli/$VERSION
current-version: sha256:$content_hash
version-history:
  - sha256:$content_hash ($timestamp)
signature: $signature
---"

    # Write canonical file
    local canonical_path="$date_dir/$base_filename"
    echo "$frontmatter" > "$canonical_path"
    echo "" >> "$canonical_path"
    cat "$input_file" >> "$canonical_path"
    success_human "Created canonical file: $canonical_path"

    # Initialize version history with full content
    initialize_version_history "$canonical_path" "$content_hash" "$timestamp" "$content"
    local versions_file=$(get_versions_file_path "$canonical_path")
    success_human "Created versions file: $versions_file"

    # Clean up temp file
    rm -f "$temp_file"

    # Handle cleanup based on mode
    if [ "$stdin_mode" = true ]; then
        # Cleanup handled by trap - just inform user
        success_human "Published content from stdin to $canonical_path"
    else
        # Remove original file if it's not already in the posts directory
        # (we've now moved it into posts with frontmatter added)
        local canonical_abs=$(realpath "$canonical_path" 2>/dev/null || readlink -f "$canonical_path" 2>/dev/null || echo "$canonical_path")
        if [ "$input_file" != "$canonical_abs" ]; then
            rm -f "$original_file"
            success_human "Moved original file into posts/"
        fi
    fi

    # Append to public.jsonl index
    append_to_index "$canonical_path" "post"

    # Output results
    if [ "$JSON_MODE" = true ]; then
        # Build canonical URL
        local canonical_url=""
        if [ -n "$POLIS_BASE_URL" ]; then
            canonical_url="$POLIS_BASE_URL/$canonical_path"
        fi

        local result=$(jq -n \
            --arg path "$canonical_path" \
            --arg hash "sha256:$content_hash" \
            --arg timestamp "$timestamp" \
            --arg sig "$signature" \
            --arg url "$canonical_url" \
            '{
                file_path: $path,
                content_hash: $hash,
                timestamp: $timestamp,
                signature: $sig,
                canonical_url: $url
            }')
        json_success "publish" "$result"
    else
        success "Publishing complete!"
        echo ""
        info "Canonical: $canonical_path"
        info "Versions:  $versions_file"
    fi
}

# ============================================================================
# DOMAIN MIGRATION COMMAND
# ============================================================================

# Detect current domain from existing published files
detect_current_domain() {
    # Check posts first
    local file
    for file in $(find "$POSTS_DIR" -name "*.md" -type f 2>/dev/null | head -5); do
        local url=$(extract_frontmatter_field "$file" "canonical_url")
        if [ -n "$url" ]; then
            extract_domain_from_url "$url"
            return 0
        fi
    done

    # Check comments
    for file in $(find "$COMMENTS_DIR" -name "*.md" -type f 2>/dev/null | head -5); do
        local url=$(extract_frontmatter_field "$file" "canonical_url")
        if [ -n "$url" ]; then
            extract_domain_from_url "$url"
            return 0
        fi
    done

    # Fallback: check .well-known/polis endpoints
    if [ -f "$WELL_KNOWN_DIR/polis" ]; then
        local posts_url=$(jq -r '.endpoints.posts // empty' "$WELL_KNOWN_DIR/polis" 2>/dev/null)
        if [ -n "$posts_url" ]; then
            extract_domain_from_url "$posts_url"
            return 0
        fi
    fi

    return 1
}

# Migrate a single post file (update canonical_url, re-sign)
migrate_post_file() {
    local file="$1"
    local old_domain="$2"
    local new_domain="$3"

    # Read current canonical_url
    local current_url=$(extract_frontmatter_field "$file" "canonical_url")
    if [ -z "$current_url" ]; then
        return 1  # No canonical_url, skip
    fi

    # Check if this file is from the old domain
    local file_domain=$(extract_domain_from_url "$current_url")
    if [ "$file_domain" != "$old_domain" ]; then
        return 1  # Not from old domain, skip
    fi

    # Replace domain in canonical_url
    local new_url="${current_url/https:\/\/$old_domain\//https:\/\/$new_domain\/}"

    # Update frontmatter using sed (portable)
    sed -i.bak "s|canonical_url: $current_url|canonical_url: $new_url|" "$file"
    rm -f "$file.bak"

    # Re-sign the file
    local temp_file=$(mktemp)
    cat "$file" > "$temp_file"
    local signature=$(sign_file "$temp_file")
    rm -f "$temp_file" "$temp_file.sig"

    # Update signature in file
    sed -i.bak "s|^signature: .*|signature: $signature|" "$file"
    rm -f "$file.bak"

    return 0
}

# Migrate a single comment file (update URLs, re-sign)
migrate_comment_file() {
    local file="$1"
    local old_domain="$2"
    local new_domain="$3"

    # Read current canonical_url
    local canonical_url=$(extract_frontmatter_field "$file" "canonical_url")
    if [ -z "$canonical_url" ]; then
        return 1  # No canonical_url, skip
    fi

    # Check if this file is from the old domain
    local file_domain=$(extract_domain_from_url "$canonical_url")
    if [ "$file_domain" != "$old_domain" ]; then
        return 1  # Not from old domain, skip
    fi

    # Replace domain in canonical_url (always)
    local new_canonical="${canonical_url/https:\/\/$old_domain\//https:\/\/$new_domain\/}"
    sed -i.bak "s|canonical_url: $canonical_url|canonical_url: $new_canonical|" "$file"
    rm -f "$file.bak"

    # Extract in-reply-to section
    local in_reply_to=$(extract_in_reply_to "$file")
    local reply_url=$(echo "$in_reply_to" | grep 'url:' | sed 's/.*url: *//')
    local root_post=$(echo "$in_reply_to" | grep 'root-post:' | sed 's/.*root-post: *//')

    # Update in_reply_to URL only if pointing to own domain
    if [ -n "$reply_url" ]; then
        local reply_domain=$(extract_domain_from_url "$reply_url")
        if [ "$reply_domain" = "$old_domain" ]; then
            local new_reply="${reply_url/https:\/\/$old_domain\//https:\/\/$new_domain\/}"
            sed -i.bak "s|url: $reply_url|url: $new_reply|" "$file"
            rm -f "$file.bak"
        fi
    fi

    # Update root_post URL only if pointing to own domain
    if [ -n "$root_post" ]; then
        local root_domain=$(extract_domain_from_url "$root_post")
        if [ "$root_domain" = "$old_domain" ]; then
            local new_root="${root_post/https:\/\/$old_domain\//https:\/\/$new_domain\/}"
            sed -i.bak "s|root-post: $root_post|root-post: $new_root|" "$file"
            rm -f "$file.bak"
        fi
    fi

    # CRITICAL: Re-sign the comment with new canonical payload
    # Comments include comment_url in signed payload, so this is mandatory
    resign_comment_for_migration "$file" "$new_domain"

    return 0
}

# Re-sign a comment file after migration (creates new signature for beseech payload)
resign_comment_for_migration() {
    local file="$1"
    local new_domain="$2"

    # Extract all fields needed for signing
    local canonical_url=$(extract_frontmatter_field "$file" "canonical_url")
    local version=$(extract_frontmatter_field "$file" "current-version")
    local published=$(extract_frontmatter_field "$file" "published")

    # Extract in-reply-to section
    local in_reply_to=$(extract_in_reply_to "$file")
    local reply_url=$(echo "$in_reply_to" | grep 'url:' | sed 's/.*url: *//')
    local reply_version=$(echo "$in_reply_to" | grep 'version:' | sed 's/.*version: *//')
    local root_post=$(echo "$in_reply_to" | grep 'root-post:' | sed 's/.*root-post: *//')

    # Get author from .well-known/polis
    local author=""
    if [ -f "$WELL_KNOWN_DIR/polis" ]; then
        author=$(jq -r '.author.email // empty' "$WELL_KNOWN_DIR/polis" 2>/dev/null)
    fi

    if [ -z "$author" ]; then
        warn_human "Could not determine author email for re-signing"
        return 1
    fi

    # Build canonical JSON payload (matches _internal_beseech_from_file format exactly)
    local canonical_payload
    if [ -n "$reply_version" ]; then
        canonical_payload=$(printf '{"comment_url":"%s","comment_version":"%s","in_reply_to":"%s","in_reply_to_version":"%s","root_post":"%s","author":"%s","timestamp":"%s"}' \
            "$canonical_url" "$version" "$reply_url" "$reply_version" "$root_post" "$author" "$published")
    else
        canonical_payload=$(printf '{"comment_url":"%s","comment_version":"%s","in_reply_to":"%s","root_post":"%s","author":"%s","timestamp":"%s"}' \
            "$canonical_url" "$version" "$reply_url" "$root_post" "$author" "$published")
    fi

    # Sign the payload
    local temp_file=$(mktemp)
    echo -n "$canonical_payload" > "$temp_file"

    local keyfile="$KEYS_DIR/id_ed25519"
    ssh-keygen -Y sign -f "$keyfile" -n file "$temp_file" > /dev/null 2>&1

    local new_signature=$(grep -v '^-----' "$temp_file.sig" | tr -d '\n')
    rm -f "$temp_file" "$temp_file.sig"

    # Update signature in file
    sed -i.bak "s|^signature: .*|signature: $new_signature|" "$file"
    rm -f "$file.bak"

    return 0
}

# Update blessed-comments.json with new domain
update_blessed_comments_urls() {
    local old_domain="$1"
    local new_domain="$2"
    local blessed_file="$BLESSED_COMMENTS"

    if [ ! -f "$blessed_file" ]; then
        return 0
    fi

    # Use jq to update post URLs that match old domain
    local temp_file="${blessed_file}.tmp"

    jq --arg old "https://$old_domain/" \
       --arg new "https://$new_domain/" \
       '
       .comments |= map(
         if .post | startswith($old) then
           .post |= sub($old; $new)
         else . end
       )
       ' "$blessed_file" > "$temp_file"

    mv "$temp_file" "$blessed_file"
}

# Update .well-known/polis endpoints with new domain
update_wellknown_endpoints() {
    local old_domain="$1"
    local new_domain="$2"
    local wellknown_file="$WELL_KNOWN_DIR/polis"

    if [ ! -f "$wellknown_file" ]; then
        return 0
    fi

    # Update endpoints URLs
    local temp_file="${wellknown_file}.tmp"

    jq --arg old "https://$old_domain/" \
       --arg new "https://$new_domain/" \
       '
       .endpoints.posts |= (if . then sub($old; $new) else . end) |
       .endpoints.blessed_comments |= (if . then sub($old; $new) else . end)
       ' "$wellknown_file" > "$temp_file"

    mv "$temp_file" "$wellknown_file"
}

# Main migrate command
cmd_migrate() {
    local new_domain="$1"

    # Validate input
    if [ -z "$new_domain" ]; then
        if [ "$JSON_MODE" = true ]; then
            json_error "migrate" "INVALID_INPUT" "Usage: polis migrate <new-domain>"
        else
            error "Usage: polis migrate <new-domain>"
        fi
    fi

    # Validate new domain format (must not include protocol)
    if [[ "$new_domain" =~ ^https?:// ]]; then
        if [ "$JSON_MODE" = true ]; then
            json_error "migrate" "INVALID_INPUT" "Domain should not include protocol (use: example.com not https://example.com)"
        else
            error "Domain should not include protocol (use: example.com not https://example.com)"
        fi
    fi

    # Auto-detect old domain from existing files
    local old_domain=$(detect_current_domain)
    if [ -z "$old_domain" ]; then
        if [ "$JSON_MODE" = true ]; then
            json_error "migrate" "NO_CONTENT" "No published content found. Nothing to migrate."
        else
            error "No published content found. Nothing to migrate."
        fi
    fi

    # Check if domains are the same
    if [ "$old_domain" = "$new_domain" ]; then
        if [ "$JSON_MODE" = true ]; then
            json_error "migrate" "INVALID_INPUT" "New domain is the same as current domain: $old_domain"
        else
            error "New domain is the same as current domain: $old_domain"
        fi
    fi

    # Confirm with user (unless --json mode)
    if [ "$JSON_MODE" = false ]; then
        info "Detected current domain: $old_domain"
        info "New domain: $new_domain"
        echo ""
        read -p "Continue with migration? (y/N) " confirm
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            error "Migration cancelled"
        fi
    fi

    # Track statistics
    local posts_updated=0
    local comments_updated=0
    local errors=()

    # Update posts
    info_human "Updating posts..."
    local file
    for file in $(find "$POSTS_DIR" -name "*.md" -type f 2>/dev/null); do
        if migrate_post_file "$file" "$old_domain" "$new_domain"; then
            ((posts_updated++))
        fi
    done

    # Update comments
    info_human "Updating comments..."
    for file in $(find "$COMMENTS_DIR" -name "*.md" -type f 2>/dev/null); do
        if migrate_comment_file "$file" "$old_domain" "$new_domain"; then
            ((comments_updated++))
        fi
    done

    # Update blessed-comments.json
    info_human "Updating blessed-comments.json..."
    update_blessed_comments_urls "$old_domain" "$new_domain"

    # Update .well-known/polis
    info_human "Updating .well-known/polis..."
    update_wellknown_endpoints "$old_domain" "$new_domain"

    # Rebuild public.jsonl index
    info_human "Rebuilding public.jsonl index..."
    cmd_rebuild > /dev/null 2>&1

    # Update discovery service database (if endpoint is configured)
    local db_updated=false
    local db_rows=0
    if [ -n "$POLIS_ENDPOINT_BASE" ] && [ -n "$DISCOVERY_SERVICE_KEY" ]; then
        info_human "Updating discovery service database..."

        # Create payload
        local migrate_payload=$(jq -n \
            --arg old "$old_domain" \
            --arg new "$new_domain" \
            '{old_domain: $old, new_domain: $new}')

        # Sign the payload
        local temp_file=$(mktemp)
        echo -n "$migrate_payload" > "$temp_file"
        local keyfile="$KEYS_DIR/id_ed25519"
        ssh-keygen -Y sign -f "$keyfile" -n file "$temp_file" > /dev/null 2>&1
        local signature=$(cat "$temp_file.sig")
        rm -f "$temp_file" "$temp_file.sig"

        # Create final payload with signature
        local final_payload=$(jq -n \
            --arg old "$old_domain" \
            --arg new "$new_domain" \
            --arg sig "$signature" \
            '{old_domain: $old, new_domain: $new, signature: $sig}')

        # Call edge function
        local migrate_endpoint="${POLIS_ENDPOINT_BASE}/migrations"
        local response=$(curl -s -w "\n%{http_code}" \
            --location --request POST "$migrate_endpoint" \
            --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
            --header 'Content-Type: application/json' \
            --data "$final_payload" 2>&1)

        local http_code=$(echo "$response" | tail -n 1)
        local response_body=$(echo "$response" | sed '$d')

        if [ "$http_code" = "200" ]; then
            db_updated=true
            db_rows=$(echo "$response_body" | jq -r '.rows_updated // 0' 2>/dev/null || echo "0")
            success_human "Database migration complete ($db_rows rows updated)"
        else
            warn_human "Database migration returned HTTP $http_code. You may need to re-beseech comments."
        fi
    else
        info_human "Discovery service not configured - skipping database migration"
    fi

    # Output results
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --arg old "$old_domain" \
            --arg new "$new_domain" \
            --argjson posts "$posts_updated" \
            --argjson comments "$comments_updated" \
            --argjson db_updated "$db_updated" \
            --argjson db_rows "$db_rows" \
            '{
                old_domain: $old,
                new_domain: $new,
                posts_updated: $posts,
                comments_updated: $comments,
                database_updated: $db_updated,
                database_rows: $db_rows
            }')
        json_success "migrate" "$result"
    else
        echo ""
        success "Migration complete!"
        echo ""
        info "Old domain: $old_domain"
        info "New domain: $new_domain"
        info "Posts updated: $posts_updated"
        info "Comments updated: $comments_updated"
        if [ "$db_updated" = true ]; then
            info "Database rows updated: $db_rows"
        fi
        echo ""
        info "Next steps:"
        info "1. Deploy to new domain"
        info "2. Set up redirect from old domain (recommended)"
        info "3. Update POLIS_BASE_URL environment variable"
    fi
}

# ============================================================================
# NOTIFICATIONS COMMAND
# ============================================================================

cmd_notifications() {
    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "notifications" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    local has_notifications=false
    local pending_blessings="[]"
    local pending_count=0
    local migrations="[]"
    local migration_count=0

    # --- Pending Blessings ---
    if [ -n "$POLIS_ENDPOINT_BASE" ] && [ -n "$DISCOVERY_SERVICE_KEY" ]; then
        local domain=$(extract_domain_from_url "$POLIS_BASE_URL")
        if [ -n "$domain" ]; then
            local blessing_response=$(curl -s --max-time 30 \
                --header "Authorization: Bearer $DISCOVERY_SERVICE_KEY" \
                "${POLIS_BLESSING_REQUESTS_ENDPOINT}?in_reply_to_domain=${domain}" 2>/dev/null)

            if [ -n "$blessing_response" ]; then
                pending_count=$(echo "$blessing_response" | jq -r '.count // 0' 2>/dev/null)
                if [ "$pending_count" -gt 0 ]; then
                    has_notifications=true
                    pending_blessings=$(echo "$blessing_response" | jq -c '.requests // []' 2>/dev/null)
                fi
            fi
        fi
    fi

    # --- Domain Migrations ---
    local relevant_domains=$(collect_relevant_domains | paste -sd ',' -)

    if [ -n "$relevant_domains" ] && [ -n "$POLIS_ENDPOINT_BASE" ]; then
        local migration_response=$(query_domain_migrations "$relevant_domains")
        migration_count=$(echo "$migration_response" | jq -r '.count // 0' 2>/dev/null)

        if [ "$migration_count" -gt 0 ]; then
            has_notifications=true
            migrations=$(echo "$migration_response" | jq -c '.migrations // []' 2>/dev/null)
        fi
    fi

    # --- Output ---
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --argjson blessings "$pending_blessings" \
            --argjson migrations "$migrations" \
            '{
                pending_blessings: $blessings,
                domain_migrations: $migrations
            }')
        json_success "notifications" "$result"
    else
        if [ "$has_notifications" = false ]; then
            info "No new notifications"
            return
        fi

        echo ""

        # Display pending blessings
        if [ "$pending_count" -gt 0 ]; then
            info "=== Pending Blessing Requests ($pending_count) ==="
            echo "$pending_blessings" | jq -r '.[] | "  #\(.id): \(.author) on \(.in_reply_to | split("/")[-1])"' 2>/dev/null
            echo ""
            info "Run 'polis blessing requests' for details, or 'polis blessing grant <id>' to approve."
            echo ""
        fi

        # Display migrations
        if [ "$migration_count" -gt 0 ]; then
            info "=== Domain Migrations ($migration_count) ==="
            echo "$migrations" | jq -r '.[] | "  \(.old_domain) -> \(.new_domain) (\(.migrated_at[:10]))"' 2>/dev/null
            echo ""
            info "Run 'polis migrations apply' to update local references."
        fi
    fi
}

# ============================================================================
# MIGRATIONS APPLY COMMAND
# ============================================================================

cmd_migrations_apply() {
    local specific_migration="$1"  # Optional: old_domain to apply

    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "migrations-apply" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Collect relevant domains and query migrations
    local relevant_domains=$(collect_relevant_domains | paste -sd ',' -)

    if [ -z "$relevant_domains" ]; then
        if [ "$JSON_MODE" = true ]; then
            json_success "migrations-apply" '{"migrations_applied":0,"files_updated":[],"message":"No relevant domains found in local files."}'
        else
            info "No relevant domains found in local files."
        fi
        return
    fi

    local migration_response=$(query_domain_migrations "$relevant_domains")
    local migration_count=$(echo "$migration_response" | jq -r '.count // 0' 2>/dev/null)

    if [ "$migration_count" -eq 0 ]; then
        if [ "$JSON_MODE" = true ]; then
            json_success "migrations-apply" '{"migrations_applied":0,"files_updated":[],"message":"No pending migrations found."}'
        else
            info "No pending migrations found."
        fi
        return
    fi

    local applied_count=0
    local all_updated_files=()

    # Process each migration
    while IFS= read -r migration; do
        [ -z "$migration" ] && continue

        local old_domain=$(echo "$migration" | jq -r '.old_domain')
        local new_domain=$(echo "$migration" | jq -r '.new_domain')
        local migrated_at=$(echo "$migration" | jq -r '.migrated_at')
        local stored_public_key=$(echo "$migration" | jq -r '.public_key')

        # Skip if specific migration requested and doesn't match
        if [ -n "$specific_migration" ] && [ "$old_domain" != "$specific_migration" ]; then
            continue
        fi

        if [ "$JSON_MODE" = false ]; then
            echo ""
            info "Migration: $old_domain -> $new_domain (${migrated_at:0:10})"
        fi

        # === KEY CONTINUITY CHECK ===
        # Verify the new domain has the same public key as stored in migration
        local current_public_key=$(fetch_domain_public_key "$new_domain")

        if [ -z "$current_public_key" ]; then
            if [ "$JSON_MODE" = false ]; then
                warn "  Cannot verify migration - new domain unreachable: $new_domain"
                read -p "  Apply anyway? (y/N) " confirm
                if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
                    info "  Skipped."
                    continue
                fi
            else
                # In JSON mode, skip unverifiable migrations
                continue
            fi
        elif [ "$current_public_key" != "$stored_public_key" ]; then
            if [ "$JSON_MODE" = false ]; then
                warn "  WARNING: Public key mismatch!"
                warn "  The new domain may be controlled by a different entity."
                warn "  Stored key:  ${stored_public_key:0:40}..."
                warn "  Current key: ${current_public_key:0:40}..."
                info "  Skipping for safety."
            fi
            continue
        else
            if [ "$JSON_MODE" = false ]; then
                success_human "  Key verification passed"
            fi
        fi

        # Find affected files
        local affected_files=()

        # Check following.json
        if [ -f "$FOLLOWING_INDEX" ]; then
            if jq -e ".following[] | select(.url | contains(\"$old_domain\"))" "$FOLLOWING_INDEX" > /dev/null 2>&1; then
                affected_files+=("$FOLLOWING_INDEX")
            fi
        fi

        # Check blessed-comments.json
        if [ -f "$BLESSED_COMMENTS" ]; then
            if jq -e ".posts[] | select(.url | contains(\"$old_domain\"))" "$BLESSED_COMMENTS" > /dev/null 2>&1; then
                affected_files+=("$BLESSED_COMMENTS")
            elif jq -e ".posts[].blessed[] | select(.url | contains(\"$old_domain\"))" "$BLESSED_COMMENTS" > /dev/null 2>&1; then
                affected_files+=("$BLESSED_COMMENTS")
            fi
        fi

        # Check comment frontmatter
        if [ -d "$COMMENTS_DIR" ]; then
            for file in $(find "$COMMENTS_DIR" -name "*.md" -type f 2>/dev/null); do
                if grep -q "https://$old_domain/" "$file" 2>/dev/null; then
                    affected_files+=("$file")
                fi
            done
        fi

        if [ ${#affected_files[@]} -eq 0 ]; then
            if [ "$JSON_MODE" = false ]; then
                info "  No local references to $old_domain found."
            fi
            continue
        fi

        # Display affected files (human mode)
        if [ "$JSON_MODE" = false ]; then
            info "  Affected files (${#affected_files[@]}):"
            for f in "${affected_files[@]}"; do
                echo "    - $f"
            done
            echo ""

            # Confirm
            read -p "  Apply this migration? (y/N) " confirm
            if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
                info "  Skipped."
                continue
            fi
        fi

        # Apply updates
        local updated_count=0

        for file in "${affected_files[@]}"; do
            if [ "$file" = "$FOLLOWING_INDEX" ]; then
                update_domain_in_following "$old_domain" "$new_domain"
                ((updated_count++))
                all_updated_files+=("$file")
            elif [ "$file" = "$BLESSED_COMMENTS" ]; then
                update_domain_in_blessed_comments "$old_domain" "$new_domain"
                ((updated_count++))
                all_updated_files+=("$file")
            elif [[ "$file" == *.md ]]; then
                update_domain_in_comment_file "$file" "$old_domain" "$new_domain"
                ((updated_count++))
                all_updated_files+=("$file")
            fi
        done

        ((applied_count++))

        if [ "$JSON_MODE" = false ]; then
            success "  Applied: $updated_count file(s) updated."
        fi

    done < <(echo "$migration_response" | jq -c '.migrations[]' 2>/dev/null)

    # Final output
    if [ "$JSON_MODE" = true ]; then
        # Deduplicate files
        local unique_files=$(printf '%s\n' "${all_updated_files[@]}" | sort -u | jq -R . | jq -s .)
        local result=$(jq -n \
            --argjson applied "$applied_count" \
            --argjson files "$unique_files" \
            '{migrations_applied: $applied, files_updated: $files}')
        json_success "migrations-apply" "$result"
    else
        echo ""
        if [ "$applied_count" -gt 0 ]; then
            success "Applied $applied_count migration(s)."
        else
            info "No migrations applied."
        fi
    fi
}

# ============================================================================
# RENDER COMMAND - HTML TEMPLATING
# ============================================================================

# Default templates (used if .polis/templates/ doesn't exist)
DEFAULT_TEMPLATE_POST='<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}} - {{site_title}}</title>
    <style>
        body { font-family: Georgia, serif; max-width: 720px; margin: 0 auto; padding: 2rem; line-height: 1.7; color: #2d2844; background: #f8f7fc; }
        header { margin-bottom: 2rem; }
        header a { color: #6b4db3; text-decoration: none; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        time { color: #5c5677; font-style: italic; }
        .content { margin: 2rem 0; }
        .signature { font-size: 0.85rem; color: #5c5677; padding-top: 1rem; border-top: 1px solid #e8e4f4; }
        .signature code { background: #e8e4f4; padding: 0.2em 0.4em; border-radius: 3px; font-size: 0.85em; }
        .comments { margin-top: 3rem; padding-top: 2rem; border-top: 2px solid #e8e4f4; }
        .comments h2 { font-size: 1.25rem; }
        .comment { margin: 1.5rem 0; padding: 1rem; background: #fff; border-radius: 6px; border: 1px solid #e8e4f4; }
        .comment header { margin-bottom: 0.5rem; font-size: 0.9rem; }
        .comment-content { font-size: 0.95rem; }
    </style>
</head>
<body>
    <header>
        <a href="{{site_url}}">{{site_title}}</a>
    </header>
    <article>
        <h1>{{title}}</h1>
        <time datetime="{{published}}">{{published_human}}</time>
        <div class="content">{{content}}</div>
        <footer class="signature">
            Signed: <code>{{signature_short}}</code> &middot; <a href="{{url}}">Permalink</a>
        </footer>
    </article>
    <section class="comments">
        <h2>Comments ({{blessed_count}})</h2>
        {{blessed_comments}}
    </section>
</body>
</html>'

DEFAULT_TEMPLATE_COMMENT='<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}} - {{site_title}}</title>
    <style>
        body { font-family: Georgia, serif; max-width: 720px; margin: 0 auto; padding: 2rem; line-height: 1.7; color: #2d2844; background: #f8f7fc; }
        header { margin-bottom: 2rem; }
        header a { color: #6b4db3; text-decoration: none; }
        h1 { font-size: 1.75rem; margin-bottom: 0.5rem; }
        time { color: #5c5677; font-style: italic; }
        .reply-to { font-size: 0.9rem; color: #5c5677; margin-bottom: 1rem; }
        .content { margin: 2rem 0; }
        .signature { font-size: 0.85rem; color: #5c5677; padding-top: 1rem; border-top: 1px solid #e8e4f4; }
        .signature code { background: #e8e4f4; padding: 0.2em 0.4em; border-radius: 3px; font-size: 0.85em; }
    </style>
</head>
<body>
    <header>
        <a href="{{site_url}}">{{site_title}}</a>
    </header>
    <article>
        <h1>{{title}}</h1>
        <time datetime="{{published}}">{{published_human}}</time>
        <p class="reply-to">In reply to: <a href="{{in_reply_to_url}}">{{in_reply_to_url}}</a></p>
        <div class="content">{{content}}</div>
        <footer class="signature">
            Signed: <code>{{signature_short}}</code> &middot; <a href="{{url}}">Permalink</a>
        </footer>
    </article>
</body>
</html>'

DEFAULT_TEMPLATE_COMMENT_INLINE='<article class="comment">
    <header>
        <a href="{{author_url}}">{{author_name}}</a> &middot;
        <time datetime="{{published}}">{{published_human}}</time>
    </header>
    <div class="comment-content">{{content}}</div>
    <footer>
        <a href="{{url}}">Permalink</a>
    </footer>
</article>'

DEFAULT_TEMPLATE_INDEX='<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{site_title}}</title>
    <style>
        body { font-family: Georgia, serif; max-width: 720px; margin: 0 auto; padding: 2rem; line-height: 1.7; color: #2d2844; background: #f8f7fc; }
        h1 { font-size: 2rem; margin-bottom: 2rem; }
        h2 { font-size: 1.5rem; margin-top: 2rem; color: #5a3d96; }
        ul { list-style: none; padding: 0; }
        li { margin: 1rem 0; padding-bottom: 1rem; border-bottom: 1px solid #e8e4f4; }
        li:last-child { border-bottom: none; }
        a { color: #6b4db3; }
        time { color: #5c5677; font-size: 0.9rem; }
        .count { color: #5c5677; font-size: 0.9rem; }
        footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #e8e4f4; font-size: 0.85rem; color: #5c5677; }
    </style>
</head>
<body>
    <h1>{{site_title}}</h1>
    <p class="count">{{post_count}} posts</p>
    <section>
        <h2>Posts</h2>
        <ul>
{{posts_list}}
        </ul>
    </section>
    <footer>
        Powered by <a href="https://github.com/vdibart/polis-cli">Polis</a> &middot; &copy; {{year}}
    </footer>
</body>
</html>'

# Template storage (associative array)
declare -A TEMPLATES

# Load templates from .polis/templates/ or use defaults
load_templates() {
    local template_dir=".polis/templates"

    if [ -f "$template_dir/post.html" ]; then
        TEMPLATES[post]=$(cat "$template_dir/post.html")
    else
        TEMPLATES[post]="$DEFAULT_TEMPLATE_POST"
    fi

    if [ -f "$template_dir/comment.html" ]; then
        TEMPLATES[comment]=$(cat "$template_dir/comment.html")
    else
        TEMPLATES[comment]="$DEFAULT_TEMPLATE_COMMENT"
    fi

    if [ -f "$template_dir/comment-inline.html" ]; then
        TEMPLATES[comment_inline]=$(cat "$template_dir/comment-inline.html")
    else
        TEMPLATES[comment_inline]="$DEFAULT_TEMPLATE_COMMENT_INLINE"
    fi

    if [ -f "$template_dir/index.html" ]; then
        TEMPLATES[index]=$(cat "$template_dir/index.html")
    else
        TEMPLATES[index]="$DEFAULT_TEMPLATE_INDEX"
    fi
}

# Initialize templates directory with defaults
init_templates() {
    local template_dir=".polis/templates"

    mkdir -p "$template_dir"

    echo "$DEFAULT_TEMPLATE_POST" > "$template_dir/post.html"
    echo "$DEFAULT_TEMPLATE_COMMENT" > "$template_dir/comment.html"
    echo "$DEFAULT_TEMPLATE_COMMENT_INLINE" > "$template_dir/comment-inline.html"
    echo "$DEFAULT_TEMPLATE_INDEX" > "$template_dir/index.html"

    if [ "$JSON_MODE" = true ]; then
        json_success "render" '{"templates_created": 4, "path": ".polis/templates/"}'
    else
        success "Created template files in $template_dir/"
        info "  - post.html"
        info "  - comment.html"
        info "  - comment-inline.html"
        info "  - index.html"
        info "Edit these files to customize your HTML output."
    fi
}

# Format date for human display
format_date_human() {
    local iso_date="$1"
    # Convert ISO date to human-readable format
    if [[ "$OSTYPE" == "darwin"* ]]; then
        date -j -f "%Y-%m-%dT%H:%M:%SZ" "$iso_date" "+%B %d, %Y" 2>/dev/null || echo "$iso_date"
    else
        date -d "$iso_date" "+%B %d, %Y" 2>/dev/null || echo "$iso_date"
    fi
}

# Escape special characters for bash pattern replacement
# In ${var//pattern/replacement}, & and \ are special in the replacement string
escape_for_replacement() {
    local str="$1"
    # Escape backslashes first, then ampersands
    str="${str//\\/\\\\}"
    str="${str//&/\\&}"
    printf '%s' "$str"
}

# Substitute template variables
substitute_template() {
    local template="$1"
    local -n vars=$2  # nameref to associative array

    local result="$template"
    for key in "${!vars[@]}"; do
        local value="${vars[$key]}"
        # Escape special characters in value for sed
        value=$(printf '%s' "$value" | sed 's/[&/\]/\\&/g')
        result=$(echo "$result" | sed "s|{{${key}}}|${value}|g")
    done
    echo "$result"
}

# Extract body from a file (not content string)
extract_body_from_file() {
    local file="$1"
    awk '/^---$/{if(++count==2){skip=0; getline; print; next} skip=1; next} !skip' "$file"
}

# Render blessed comments for a post
# Returns HTML string via stdout; stdout is captured by caller
render_blessed_comments() {
    local post_url="$1"
    local blessed_html=""
    local count=0

    # Check if blessed-comments.json exists
    if [ ! -f "$BLESSED_COMMENTS" ]; then
        echo ""
        return
    fi

    # Get blessed comments for this post
    # Use -c for compact output (one JSON object per line)
    local comments_json
    comments_json=$(jq -c --arg url "$post_url" '.comments[] | select(.post == $url) | .blessed[]' "$BLESSED_COMMENTS" 2>/dev/null)

    if [ -z "$comments_json" ]; then
        echo ""
        return
    fi

    # Process each blessed comment (one JSON object per line)
    while IFS= read -r comment_data; do
        [ -z "$comment_data" ] && continue

        local comment_url=$(echo "$comment_data" | jq -r '.url // empty')
        [ -z "$comment_url" ] && continue

        # Try to fetch/find the comment content
        local comment_content=""
        local comment_file=""

        # Check if it's a local comment (same domain)
        local base_url="${POLIS_BASE_URL%/}"  # Remove trailing slash
        if [[ "$comment_url" == "${base_url}"* ]]; then
            # Extract path from URL and find local file
            local url_path="${comment_url#${base_url}}"
            url_path="${url_path#/}"  # Remove leading slash(es)
            url_path="${url_path#/}"  # Handle double slash case
            if [ -f "$url_path" ]; then
                comment_file="$url_path"
                comment_content=$(cat "$comment_file")
            fi
        fi

        # If not found locally, try to fetch remotely
        if [ -z "$comment_content" ]; then
            comment_content=$(curl -sL "$comment_url" 2>/dev/null)
        fi

        # If we found content, render it
        if [ -n "$comment_content" ]; then
            local c_title=$(echo "$comment_content" | grep '^title:' | head -1 | sed 's/^title: *//')
            local c_published=$(echo "$comment_content" | grep '^published:' | head -1 | sed 's/^published: *//')
            local c_body=$(extract_body_from_content "$comment_content")
            local c_html=$(echo "$c_body" | pandoc -f markdown -t html 2>/dev/null || echo "$c_body")

            # Get author info from URL
            local author_domain=$(echo "$comment_url" | sed 's|https\?://||' | cut -d'/' -f1)

            declare -A comment_vars=(
                [author_name]="$author_domain"
                [author_url]="https://$author_domain"
                [published]="$c_published"
                [published_human]="$(format_date_human "$c_published")"
                [content]="$c_html"
                [url]="$comment_url"
            )

            local comment_html="${TEMPLATES[comment_inline]}"
            for key in "${!comment_vars[@]}"; do
                local escaped_val=$(escape_for_replacement "${comment_vars[$key]}")
                comment_html="${comment_html//\{\{$key\}\}/$escaped_val}"
            done

            blessed_html+="$comment_html"
            ((++count))  # Pre-increment to avoid set -e exit when count=0
        fi
    done <<< "$comments_json"

    echo "$blessed_html"
}

# Render a single file to HTML
render_file() {
    local input_file="$1"
    local type="$2"  # "post" or "comment"
    local force="$3"

    local output_file="${input_file%.md}.html"

    # Skip if output is newer than input (unless force)
    if [ "$force" != "true" ] && [ -f "$output_file" ] && [ "$output_file" -nt "$input_file" ]; then
        return 1  # Skipped
    fi

    # Check pandoc availability
    if ! command -v pandoc &>/dev/null; then
        error "pandoc is required for rendering. Install with: apt install pandoc (Linux) or brew install pandoc (macOS)"
    fi

    # Read file content
    local content=$(cat "$input_file")

    # Extract frontmatter fields
    local title=$(echo "$content" | grep '^title:' | head -1 | sed 's/^title: *//')
    local published=$(echo "$content" | grep '^published:' | head -1 | sed 's/^published: *//')
    local version=$(echo "$content" | grep '^current-version:' | head -1 | sed 's/^current-version: *//')
    local signature=$(echo "$content" | grep '^signature:' | head -1 | sed 's/^signature: *//')
    local signature_short="${signature:0:20}..."

    # Extract body and convert to HTML
    local body=$(extract_body_from_content "$content")
    local html_content=$(echo "$body" | pandoc -f markdown -t html 2>/dev/null || echo "$body")

    # Build canonical URL (normalize to avoid double slashes)
    local base_url="${POLIS_BASE_URL%/}"  # Remove trailing slash if present
    local url="${base_url}/${input_file}"
    info_human "  [url] Canonical URL: $url"

    # Get site info
    local site_title="${POLIS_BASE_URL#https://}"
    site_title="${site_title#http://}"

    # Get author info from .well-known/polis
    local author_name="$site_title"
    if [ -f "$WELL_KNOWN_DIR/polis" ]; then
        local wk_name=$(jq -r '.name // empty' "$WELL_KNOWN_DIR/polis" 2>/dev/null)
        [ -n "$wk_name" ] && author_name="$wk_name"
    fi

    # Choose template
    local template="${TEMPLATES[$type]}"
    [ -z "$template" ] && template="${TEMPLATES[post]}"

    # Handle blessed comments for posts
    local blessed_comments=""
    local blessed_count=0
    if [ "$type" = "post" ]; then
        blessed_comments=$(render_blessed_comments "$url")
        # Count comments (rough count by counting </article> tags)
        # Note: || must be outside subshell to avoid capturing both grep output AND fallback
        blessed_count=$(echo "$blessed_comments" | grep -c '</article>' 2>/dev/null) || blessed_count=0
    fi

    # Comment-specific fields
    local in_reply_to_url=""
    local root_post_url=""
    if [ "$type" = "comment" ]; then
        in_reply_to_url=$(echo "$content" | grep -A1 '^in-reply-to:' | grep 'url:' | sed 's/.*url: *//')
        root_post_url=$(echo "$content" | grep -A2 '^in-reply-to:' | grep 'root-post:' | sed 's/.*root-post: *//')
    fi

    # Substitute all variables
    # Note: Values containing HTML must be escaped for bash pattern replacement
    local result="$template"
    result="${result//\{\{title\}\}/$(escape_for_replacement "$title")}"
    result="${result//\{\{content\}\}/$(escape_for_replacement "$html_content")}"
    result="${result//\{\{published\}\}/$(escape_for_replacement "$(format_date_human "$published")")}"
    result="${result//\{\{published_human\}\}/$(escape_for_replacement "$(format_date_human "$published")")}"
    result="${result//\{\{url\}\}/$(escape_for_replacement "$url")}"
    result="${result//\{\{version\}\}/$(escape_for_replacement "$version")}"
    result="${result//\{\{signature_short\}\}/$(escape_for_replacement "$signature_short")}"
    result="${result//\{\{site_url\}\}/$(escape_for_replacement "$POLIS_BASE_URL")}"
    result="${result//\{\{site_title\}\}/$(escape_for_replacement "$site_title")}"
    result="${result//\{\{author_name\}\}/$(escape_for_replacement "$author_name")}"
    result="${result//\{\{author_url\}\}/$(escape_for_replacement "$POLIS_BASE_URL")}"
    result="${result//\{\{year\}\}/$(escape_for_replacement "$(date +%Y)")}"
    result="${result//\{\{blessed_comments\}\}/$(escape_for_replacement "$blessed_comments")}"
    result="${result//\{\{blessed_count\}\}/$(escape_for_replacement "$blessed_count")}"
    result="${result//\{\{in_reply_to_url\}\}/$(escape_for_replacement "$in_reply_to_url")}"
    result="${result//\{\{root_post_url\}\}/$(escape_for_replacement "$root_post_url")}"

    # Append source markdown as HTML comment
    # Escape -- sequences to prevent breaking HTML comments
    local escaped_source="${content//--/&#45;&#45;}"
    result+="
<!--
=== POLIS SOURCE ===
Source: ${input_file}
${escaped_source}
=== END POLIS SOURCE ===
-->"

    # Write output
    echo "$result" > "$output_file"
    return 0  # Rendered
}

# Render index page
render_index() {
    local posts_list=""
    local post_count=0

    # Read public.jsonl and build posts list
    if [ -f "$PUBLIC_INDEX" ]; then
        while IFS= read -r line; do
            [ -z "$line" ] && continue

            local entry_type=$(echo "$line" | jq -r '.type // "post"')
            [ "$entry_type" != "post" ] && continue

            local path=$(echo "$line" | jq -r '.path // empty')
            local title=$(echo "$line" | jq -r '.title // "Untitled"')
            local published=$(echo "$line" | jq -r '.published // empty')

            [ -z "$path" ] && continue

            local html_path="${path%.md}.html"
            local published_human=$(format_date_human "$published")

            posts_list+="            <li><a href=\"$html_path\">$title</a> <time>$published_human</time></li>
"
            ((++post_count))
        done < "$PUBLIC_INDEX"
    fi

    # Get site info
    local site_title="${POLIS_BASE_URL#https://}"
    site_title="${site_title#http://}"

    # Substitute template
    local result="${TEMPLATES[index]}"
    if [ -z "$result" ]; then
        error "Index template is empty. Run 'polis render --init-templates' or check .polis/templates/index.html"
    fi
    result="${result//\{\{site_title\}\}/$(escape_for_replacement "$site_title")}"
    result="${result//\{\{site_url\}\}/$(escape_for_replacement "$POLIS_BASE_URL")}"
    result="${result//\{\{posts_list\}\}/$(escape_for_replacement "$posts_list")}"
    result="${result//\{\{post_count\}\}/$(escape_for_replacement "$post_count")}"
    result="${result//\{\{year\}\}/$(escape_for_replacement "$(date +%Y)")}"

    echo "$result" > "index.html"
    info_human "  Written: index.html"
}

# Command: polis render
cmd_render() {
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            --init-templates)
                init_templates
                return
                ;;
            *)
                json_error "render" "INVALID_INPUT" "Unknown option: $1. Use: polis render [--force] or polis render --init-templates"
                ;;
        esac
    done

    # Check initialization
    if [ ! -f "$WELL_KNOWN_DIR/polis" ]; then
        json_error "render" "INVALID_STATE" "Polis not initialized. Run 'polis init' first."
    fi

    # Check pandoc
    if ! command -v pandoc &>/dev/null; then
        json_error "render" "MISSING_DEPENDENCY" "pandoc is required for rendering. Install with: apt install pandoc (Linux) or brew install pandoc (macOS)"
    fi

    # Load templates
    load_templates

    info_human "=== Render Configuration ==="
    info_human "Working directory: $(pwd)"
    info_human "POLIS_BASE_URL: $POLIS_BASE_URL"
    info_human "Posts dir: $POSTS_DIR"
    info_human "Comments dir: $COMMENTS_DIR"
    info_human "Blessed comments file: $BLESSED_COMMENTS"

    # Show blessed-comments.json summary
    if [ -f "$BLESSED_COMMENTS" ]; then
        local bc_posts=$(jq -r '.comments | length' "$BLESSED_COMMENTS" 2>/dev/null || echo "0")
        info_human "Blessed comments: $bc_posts post(s) with blessed comments"
        if [ "$bc_posts" -gt 0 ]; then
            info_human "Posts with blessed comments:"
            jq -r '.comments[].post' "$BLESSED_COMMENTS" 2>/dev/null | while read -r p; do
                info_human "  - $p"
            done
        fi
    else
        info_human "Blessed comments: file not found"
    fi

    info_human "Templates loaded"

    local posts_rendered=0
    local posts_skipped=0
    local comments_rendered=0
    local comments_skipped=0

    info_human ""
    info_human "=== Rendering Posts ==="

    # Render posts
    if [ -d "$POSTS_DIR" ]; then
        while IFS= read -r post_file; do
            [ -z "$post_file" ] && continue
            info_human "Processing: $post_file"
            if render_file "$post_file" "post" "$force"; then
                ((++posts_rendered))
                info_human "  -> Rendered: ${post_file%.md}.html"
            else
                ((++posts_skipped))
                info_human "  -> Skipped (up to date)"
            fi
        done < <(find "$POSTS_DIR" -name "*.md" -not -path "*/.versions/*" -type f 2>/dev/null)
    else
        info_human "Posts directory not found: $POSTS_DIR"
    fi

    info_human ""
    info_human "=== Rendering Comments ==="

    # Render comments
    if [ -d "$COMMENTS_DIR" ]; then
        while IFS= read -r comment_file; do
            [ -z "$comment_file" ] && continue
            info_human "Processing: $comment_file"
            if render_file "$comment_file" "comment" "$force"; then
                ((++comments_rendered))
                info_human "  -> Rendered: ${comment_file%.md}.html"
            else
                ((++comments_skipped))
                info_human "  -> Skipped (up to date)"
            fi
        done < <(find "$COMMENTS_DIR" -name "*.md" -not -path "*/.versions/*" -type f 2>/dev/null)
    else
        info_human "Comments directory not found: $COMMENTS_DIR"
    fi

    info_human ""
    info_human "=== Generating Index ==="

    # Generate index
    render_index
    info_human "Generated: index.html"

    # Output
    if [ "$JSON_MODE" = true ]; then
        local result=$(jq -n \
            --argjson pr "$posts_rendered" \
            --argjson ps "$posts_skipped" \
            --argjson cr "$comments_rendered" \
            --argjson cs "$comments_skipped" \
            '{posts_rendered: $pr, posts_skipped: $ps, comments_rendered: $cr, comments_skipped: $cs, index_generated: true}')
        json_success "render" "$result"
    else
        echo ""
        success "Rendering complete!"
        info "  Posts rendered: $posts_rendered (skipped: $posts_skipped)"
        info "  Comments rendered: $comments_rendered (skipped: $comments_skipped)"
        info "  Index: index.html"
    fi
}

# Main command router
main() {
    # Parse global flags before command
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                JSON_MODE=true
                # Disable colors in JSON mode
                GREEN=''
                BLUE=''
                RED=''
                NC=''
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local command="$1"
    shift

    case "$command" in
        init)
            cmd_init "$@"
            ;;
        publish)
            cmd_publish "$@"
            ;;
        comment)
            cmd_comment "$@"
            ;;
        preview)
            cmd_preview "$@"
            ;;
        republish)
            cmd_republish "$@"
            ;;
        rebuild)
            cmd_rebuild "$@"
            ;;
        index)
            cmd_index "$@"
            ;;
        version)
            cmd_version "$@"
            ;;
        rotate-key)
            cmd_rotate_key "$@"
            ;;
        get-version)
            cmd_get_version "$@"
            ;;
        blessing)
            cmd_blessing "$@"
            ;;
        follow)
            cmd_follow "$@"
            ;;
        unfollow)
            cmd_unfollow "$@"
            ;;
        migrate)
            cmd_migrate "$@"
            ;;
        notifications)
            cmd_notifications "$@"
            ;;
        migrations)
            case "$1" in
                apply)
                    shift
                    cmd_migrations_apply "$@"
                    ;;
                *)
                    error "Unknown migrations subcommand: $1. Use: polis migrations apply"
                    ;;
            esac
            ;;
        render)
            cmd_render "$@"
            ;;
        *)
            echo "Polis - Decentralized Social Network CLI"
            echo ""
            echo "Usage:"
            echo "  polis [--json] <command> [options]"
            echo ""
            echo "Global Flags:"
            echo "  --json                          Output results in JSON format (for scripting).  Supported by most but not all commands below."
            echo ""
            echo "Commands related to publishing or viewing files or comments:"
            echo "  polis publish <file>            Publish a new post"
            echo "  polis publish -                 Publish from stdin (use --filename, --title for options)"
            echo "  polis comment <file> [url]      Create a comment on a post"
            echo "  polis comment - <url>           Comment from stdin (use --filename, --title for options)"
            echo "  polis republish <file>          Update an already-published file"
            echo "  polis preview <url>             Preview a post or comment at a URL with signature verification"
            echo ""
            echo "Commands related to requesting, reviewing, or granting blessings on comments:"
            echo "  polis blessing requests         List pending blessing requests; use 'polis preview' to see details"
            echo "  polis blessing grant <id>       Grant a blessing request"
            echo "  polis blessing deny <id>        Deny a blessing request"
            echo "  polis blessing beseech <id>     Re-request blessing by ID"
            echo "  polis blessing sync             Sync auto-blessed comments from discovery service"
            echo ""
            echo "Commands related to following or unfollowing an author:"
            echo "  polis follow <author-url>       Follow an author (auto-bless their comments)"
            echo "  polis unfollow <author-url>     Unfollow an author"
            echo ""
            echo "Commands related to site administration:"
            echo "  polis render [--force]          Render markdown posts and comments to HTML"
            echo "  polis render --init-templates   Create .polis/templates/ with default templates for customization"
            echo "  polis notifications             Show pending actions (blessing requests, domain migrations)"
            echo "  polis migrate <new-domain>      Migrate all content to a new domain (re-signs files, updates DB)"
            echo "  polis migrations apply          Apply discovered domain migrations to local files"
            echo ""
            echo "Commands related to local configuration management:"
            echo "  polis init [options]            Initialize Polis directory structure"
            echo "    --keys-dir <path>             Custom keys directory (default: .polis/keys)"
            echo "    --posts-dir <path>            Custom posts directory (default: posts)"
            echo "    --comments-dir <path>         Custom comments directory (default: comments)"
            echo "    --versions-dir <path>         Custom versions directory (default: .versions)"
            echo "  polis rebuild --content|--comments|--all"
            echo "                                  Rebuild local indexes (flags are combinable)"
            echo "  polis index [--json]            View index (JSONL or JSON format)"
            echo "  polis version                   Print CLI version"
            echo "  polis rotate-key [--delete-old-key]"
            echo "                                  Generate new keypair and re-sign all content"
            echo "  polis get-version <file> <hash> Reconstruct a specific version of a file"
            echo ""
            echo "Polis includes support for stdin:"
            echo "  Pipe content directly without creating temporary files:"
            echo "    echo '# My Post' | polis publish -"
            echo "    echo '# Reply' | polis comment - https://example.com/post.md"
            echo "    curl -s https://example.com/draft.md | polis publish - --filename final.md"
            echo "    polis publish - --title 'My Title' --filename custom.md < content.txt"
            echo ""
            echo "Polis commands can output results as JSON for scripting and testing:"
            echo "  When --json is enabled:"
            echo "    - Output is valid JSON to stdout (success) or stderr (errors)"
            echo "    - Interactive prompts are auto-skipped with logged defaults"
            echo "    - ANSI color codes are disabled"
            echo "    - Exit codes: 0 (success) or 1 (error)"
            echo ""
            echo "  Example:"
            echo "    polis --json publish my-post.md | jq -r '.data.content_hash'"
            echo "    polis --json comment my-comment.md https://example.com/post.md"
            echo "    echo '# Test' | polis --json publish - | jq"
            echo ""
            echo "Configuration (in order of precedence):"
            echo "  1. Environment variables"
            echo "  2. .env file in current directory"
            echo "  3. config section in .well-known/polis"
            echo "  4. Built-in defaults"
            echo ""
            echo "Required for blessing commands:"
            echo "  POLIS_BASE_URL                  Your public HTTPS URL"
            echo "  DISCOVERY_SERVICE_KEY           Discovery service API key"
            echo ""
            echo "Optional:"
            echo "  POLIS_ENDPOINT_BASE             Discovery service base URL (has default)"
            echo "  KEYS_DIR, POSTS_DIR, etc.       Custom directory paths"
            echo ""
            echo "Create a .env file from template:"
            echo "  cp .env.example .env && vim .env"
            echo ""
            echo "Initialize with custom paths:"
            echo "  polis init --posts-dir articles --comments-dir replies"
            echo ""
            exit 1
            ;;
    esac
}

main "$@"
