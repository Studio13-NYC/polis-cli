#!/usr/bin/env bash
#
# polis-upgrade - Upgrade script for Polis CLI/TUI
#
# Handles version migrations and binary updates via CURL (no git dependency).
# Fetches migration scripts from GitHub (tag-pinned) and verifies SHA-256
# checksums before execution.
#
# Usage:
#   polis-upgrade [OPTIONS]
#
# Options:
#   --component cli|tui   Component to upgrade (default: cli)
#   --from VERSION        Override current version detection
#   --to VERSION          Upgrade to specific version (default: latest)
#   --polis-path PATH     Path to polis CLI script (auto-detected if omitted)
#   --site-dir PATH       Path to polis site directory (auto-detected if omitted)
#   --yes                 Skip confirmation prompts
#   --check               Only check for updates, don't apply
#   --help                Show this help message
#
# Dependencies: bash 4.0+, curl, jq, sha256sum/shasum
#

set -euo pipefail

# ============================================================================
# CONSTANTS
# ============================================================================

UPGRADE_VERSION="0.1.0"
GITHUB_REPO="vdibart/polis"
GITHUB_RAW_BASE="https://raw.githubusercontent.com/${GITHUB_REPO}"

# Colors
GREEN='\033[0;32m'
CYAN='\033[0;36m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Disable colors if not a terminal
if [[ ! -t 1 ]]; then
    GREEN='' CYAN='' RED='' YELLOW='' BOLD='' DIM='' NC=''
fi

# ============================================================================
# OUTPUT HELPERS
# ============================================================================

info() {
    echo -e "${CYAN}[i]${NC} $1"
}

success() {
    echo -e "${GREEN}[âœ“]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[!]${NC} $1" >&2
}

error() {
    echo -e "${RED}[x]${NC} $1" >&2
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Compare two semantic versions
# Returns: 0 if equal, 1 if a > b, 2 if a < b
compare_versions() {
    local a="$1" b="$2"
    if [[ "$a" == "$b" ]]; then
        return 0
    fi

    local IFS='.'
    local -a a_parts=($a) b_parts=($b)

    for ((i = 0; i < ${#a_parts[@]} || i < ${#b_parts[@]}; i++)); do
        local a_val=${a_parts[$i]:-0}
        local b_val=${b_parts[$i]:-0}
        if ((a_val > b_val)); then
            return 1
        elif ((a_val < b_val)); then
            return 2
        fi
    done
    return 0
}

# Compute SHA-256 hash of a file
compute_sha256() {
    local file="$1"
    if command -v sha256sum &>/dev/null; then
        sha256sum "$file" | awk '{print $1}'
    elif command -v shasum &>/dev/null; then
        shasum -a 256 "$file" | awk '{print $1}'
    else
        error "Neither sha256sum nor shasum found"
        exit 1
    fi
}

# Prompt user for yes/no (default: no)
confirm() {
    local prompt="$1"
    if [[ "${AUTO_YES:-false}" == "true" ]]; then
        return 0
    fi
    echo -en "$prompt ${DIM}[y/N]${NC} "
    read -r reply
    [[ "$reply" =~ ^[Yy]$ ]]
}

# ============================================================================
# RESOLUTION FUNCTIONS
# ============================================================================

# Resolve the site directory
resolve_site_dir() {
    # 1. --site-dir flag (already set)
    if [[ -n "${SITE_DIR:-}" ]]; then
        if [[ ! -d "$SITE_DIR" ]]; then
            error "Site directory does not exist: $SITE_DIR"
            exit 1
        fi
        return 0
    fi

    # 2. POLIS_BASE environment variable
    if [[ -n "${POLIS_BASE:-}" ]] && [[ -d "$POLIS_BASE" ]]; then
        SITE_DIR="$POLIS_BASE"
        return 0
    fi

    # 3. Read from .env in cwd
    if [[ -f ".env" ]]; then
        local base_url
        base_url=$(grep -E '^POLIS_BASE_URL=' .env 2>/dev/null | head -1 | cut -d= -f2- | tr -d '"' | tr -d "'")
        if [[ -n "$base_url" ]]; then
            # If .env exists here, cwd is likely the site dir
            SITE_DIR="$(pwd)"
            return 0
        fi
    fi

    # 4. Check if cwd contains .well-known/polis
    if [[ -f ".well-known/polis" ]]; then
        SITE_DIR="$(pwd)"
        return 0
    fi

    error "Could not determine site directory."
    echo "  Set POLIS_BASE, use --site-dir, or run from your polis site directory." >&2
    exit 1
}

# Resolve the polis CLI script path
resolve_polis_path() {
    # 1. --polis-path flag (already set)
    if [[ -n "${POLIS_PATH:-}" ]]; then
        if [[ ! -f "$POLIS_PATH" ]]; then
            error "Polis script not found at: $POLIS_PATH"
            exit 1
        fi
        return 0
    fi

    # 2. Check site directory (typical setup: CLI lives alongside content)
    if [[ -n "${SITE_DIR:-}" ]] && [[ -f "${SITE_DIR}/polis" ]]; then
        POLIS_PATH="${SITE_DIR}/polis"
        return 0
    fi

    # 3. Fall back to which
    if command -v polis &>/dev/null; then
        POLIS_PATH="$(command -v polis)"
        return 0
    fi

    error "Could not locate polis CLI script."
    echo "  Use --polis-path or ensure 'polis' is in your PATH." >&2
    exit 1
}

# Read VERSION constant from polis script
read_polis_version() {
    local script="$1"
    grep -E '^VERSION="[0-9]+\.[0-9]+\.[0-9]+"' "$script" 2>/dev/null \
        | head -1 \
        | sed 's/VERSION="//;s/"//'
}

# ============================================================================
# DISCOVERY SERVICE FUNCTIONS
# ============================================================================

# Query discovery service for latest version of a component
query_latest_version() {
    local component="$1"
    local current="${2:-}"

    # Need DISCOVERY_SERVICE_URL and DISCOVERY_SERVICE_KEY
    if [[ -z "${DISCOVERY_SERVICE_URL:-}" ]]; then
        # Try to read from .env
        if [[ -f "${SITE_DIR:-.}/.env" ]]; then
            DISCOVERY_SERVICE_URL=$(grep -E '^DISCOVERY_SERVICE_URL=' "${SITE_DIR:-.}/.env" 2>/dev/null | head -1 | cut -d= -f2- | tr -d '"' | tr -d "'")
            DISCOVERY_SERVICE_KEY=$(grep -E '^DISCOVERY_SERVICE_KEY=' "${SITE_DIR:-.}/.env" 2>/dev/null | head -1 | cut -d= -f2- | tr -d '"' | tr -d "'")
        fi
    fi

    if [[ -z "${DISCOVERY_SERVICE_URL:-}" ]]; then
        error "DISCOVERY_SERVICE_URL not set. Cannot check for updates."
        echo "  Set it in your environment or .env file." >&2
        exit 1
    fi

    local endpoint="${DISCOVERY_SERVICE_URL}/polis-version?component=${component}"
    if [[ -n "$current" ]]; then
        endpoint="${endpoint}&current=${current}"
    fi

    local response
    response=$(curl -s --max-time 15 \
        --location --request GET "$endpoint" \
        --header 'Content-Type: application/json' 2>/dev/null)

    if [[ -z "$response" ]]; then
        error "Failed to reach discovery service"
        exit 1
    fi

    # Check for error response
    local err
    err=$(echo "$response" | jq -r '.error // empty' 2>/dev/null)
    if [[ -n "$err" ]]; then
        error "Discovery service: $err"
        exit 1
    fi

    echo "$response"
}

# ============================================================================
# SELF-UPDATE CHECK
# ============================================================================

check_self_update() {
    info "Checking for polis-upgrade updates..."

    local response
    response=$(query_latest_version "upgrade" "$UPGRADE_VERSION") || return 1

    local latest
    latest=$(echo "$response" | jq -r '.latest // empty')
    local upgrade_available
    upgrade_available=$(echo "$response" | jq -r '.upgrade_available // false')

    if [[ "$upgrade_available" != "true" ]]; then
        return 0
    fi

    local download_url
    download_url=$(echo "$response" | jq -r '.download_url // empty')

    warn "polis-upgrade ${UPGRADE_VERSION} is outdated (latest: ${latest})"

    if confirm "Download latest polis-upgrade first?"; then
        info "Downloading polis-upgrade ${latest}..."

        local tmp_file
        tmp_file=$(mktemp)
        trap "rm -f '$tmp_file'" EXIT

        if ! curl -s --max-time 30 -L -o "$tmp_file" "$download_url"; then
            error "Failed to download polis-upgrade ${latest}"
            rm -f "$tmp_file"
            exit 1
        fi

        # Verify it's a valid bash script
        if ! head -1 "$tmp_file" | grep -q '^#!/'; then
            error "Downloaded file is not a valid script"
            rm -f "$tmp_file"
            exit 1
        fi

        # Replace self
        local self_path
        self_path="$(realpath "$0")"
        cp "$tmp_file" "$self_path"
        chmod +x "$self_path"
        rm -f "$tmp_file"

        success "Updated polis-upgrade to ${latest}"
        info "Restarting..."
        echo ""

        # Re-exec with same args
        exec "$self_path" "$@"
    else
        warn "Continuing with outdated polis-upgrade (some migrations may not work correctly)"
    fi
}

# ============================================================================
# MIGRATION FUNCTIONS
# ============================================================================

# Fetch manifest from GitHub (tag-pinned)
fetch_manifest() {
    local component="$1"
    local tag="$2"

    local manifest_url="${GITHUB_RAW_BASE}/v${tag}/migrations/${component}/manifest.json"

    local response
    response=$(curl -s --max-time 15 -L "$manifest_url" 2>/dev/null)

    if [[ -z "$response" ]] || echo "$response" | jq -e '.message' &>/dev/null 2>&1; then
        error "Failed to fetch migration manifest from: $manifest_url"
        echo "  Ensure the tag v${tag} exists on GitHub." >&2
        exit 1
    fi

    # Validate it's valid JSON with expected structure
    if ! echo "$response" | jq -e '.component' &>/dev/null; then
        error "Invalid manifest format (missing 'component' field)"
        exit 1
    fi

    echo "$response"
}

# Filter applicable migrations from manifest
filter_migrations() {
    local manifest="$1"
    local from_version="$2"
    local to_version="$3"

    # Use jq to filter and sort migrations
    echo "$manifest" | jq -c --arg from "$from_version" --arg to "$to_version" '
        .migrations
        | map(select(
            # from >= current_version (migration applies to users at or above this version)
            (.from | split(".") | map(tonumber)) as $mfrom |
            ($from | split(".") | map(tonumber)) as $cfrom |
            # to <= target_version
            (.to | split(".") | map(tonumber)) as $mto |
            ($to | split(".") | map(tonumber)) as $cto |
            # Compare: migration.from >= current
            (
                ($mfrom[0] > $cfrom[0]) or
                ($mfrom[0] == $cfrom[0] and $mfrom[1] > $cfrom[1]) or
                ($mfrom[0] == $cfrom[0] and $mfrom[1] == $cfrom[1] and $mfrom[2] >= $cfrom[2])
            ) and
            # Compare: migration.to <= target
            (
                ($mto[0] < $cto[0]) or
                ($mto[0] == $cto[0] and $mto[1] < $cto[1]) or
                ($mto[0] == $cto[0] and $mto[1] == $cto[1] and $mto[2] <= $cto[2])
            )
        ))
        | sort_by(.from | split(".") | map(tonumber))
    '
}

# Download and verify a migration script
download_migration() {
    local component="$1"
    local tag="$2"
    local script_name="$3"
    local expected_sha256="$4"
    local dest="$5"

    local script_url="${GITHUB_RAW_BASE}/v${tag}/migrations/${component}/${script_name}"

    if ! curl -s --max-time 30 -L -o "$dest" "$script_url"; then
        error "Failed to download migration script: $script_name"
        return 1
    fi

    # Verify checksum
    local actual_sha256
    actual_sha256=$(compute_sha256 "$dest")

    if [[ "$actual_sha256" != "$expected_sha256" ]]; then
        error "Checksum verification failed for ${script_name}"
        echo "  Expected: ${expected_sha256}" >&2
        echo "  Got:      ${actual_sha256}" >&2
        rm -f "$dest"
        return 1
    fi

    chmod +x "$dest"
    return 0
}

# ============================================================================
# MAIN WORKFLOW
# ============================================================================

show_help() {
    echo "polis-upgrade ${UPGRADE_VERSION} - Upgrade Polis CLI/TUI"
    echo ""
    echo "Usage: polis-upgrade [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --component cli|tui   Component to upgrade (default: cli)"
    echo "  --from VERSION        Override current version detection"
    echo "  --to VERSION          Upgrade to specific version (default: latest)"
    echo "  --polis-path PATH     Path to polis CLI script"
    echo "  --site-dir PATH       Path to polis site directory"
    echo "  --yes                 Skip confirmation prompts"
    echo "  --check               Only check for updates, don't apply"
    echo "  --help                Show this help message"
    echo ""
    echo "Examples:"
    echo "  polis-upgrade                      # Upgrade CLI to latest"
    echo "  polis-upgrade --to 0.39.0          # Upgrade CLI to specific version"
    echo "  polis-upgrade --component tui      # Upgrade TUI to latest"
    echo "  polis-upgrade --check              # Check what's available"
    echo "  polis-upgrade --from 0.33.0        # Override version detection"
}

main() {
    # Parse arguments
    local COMPONENT="cli"
    local FROM_VERSION=""
    local TO_VERSION=""
    local POLIS_PATH=""
    local SITE_DIR=""
    local AUTO_YES="false"
    local CHECK_ONLY="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --component)
                COMPONENT="$2"
                if [[ "$COMPONENT" != "cli" && "$COMPONENT" != "tui" ]]; then
                    error "Invalid component: $COMPONENT (must be 'cli' or 'tui')"
                    exit 1
                fi
                shift 2
                ;;
            --from)
                FROM_VERSION="$2"
                shift 2
                ;;
            --to)
                TO_VERSION="$2"
                shift 2
                ;;
            --polis-path)
                POLIS_PATH="$2"
                shift 2
                ;;
            --site-dir)
                SITE_DIR="$2"
                shift 2
                ;;
            --yes|-y)
                AUTO_YES="true"
                shift
                ;;
            --check)
                CHECK_ONLY="true"
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --version)
                echo "polis-upgrade ${UPGRADE_VERSION}"
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                echo "Run 'polis-upgrade --help' for usage." >&2
                exit 1
                ;;
        esac
    done

    # Export for use in functions
    export AUTO_YES SITE_DIR POLIS_PATH

    echo -e "${BOLD}${CYAN}polis-upgrade${NC} ${DIM}v${UPGRADE_VERSION}${NC}"
    echo ""

    # Step 1: Resolve site directory
    resolve_site_dir

    # Step 2: Self-update check
    check_self_update "$@"

    # Step 3: Resolve polis CLI path and determine current version
    if [[ -z "$FROM_VERSION" ]]; then
        resolve_polis_path

        local detected_version
        if [[ "$COMPONENT" == "cli" ]]; then
            detected_version=$(read_polis_version "$POLIS_PATH")
        else
            # For TUI, look for polis-tui in the same directory
            local tui_path="${POLIS_PATH%polis}polis-tui"
            if [[ -f "$tui_path" ]]; then
                detected_version=$(grep -E '^TUI_VERSION="[0-9]+\.[0-9]+\.[0-9]+"' "$tui_path" 2>/dev/null \
                    | head -1 | sed 's/TUI_VERSION="//;s/"//')
            fi
        fi

        if [[ -z "${detected_version:-}" ]]; then
            error "Could not detect current ${COMPONENT} version from ${POLIS_PATH}"
            echo "  Use --from VERSION to specify manually." >&2
            exit 1
        fi

        FROM_VERSION="$detected_version"
        info "Detected current ${COMPONENT} version: ${FROM_VERSION}"
    else
        info "Using specified version: ${FROM_VERSION}"
    fi

    # Step 4: Determine target version
    if [[ -z "$TO_VERSION" ]]; then
        info "Checking latest ${COMPONENT} version..."
        local version_response
        version_response=$(query_latest_version "$COMPONENT" "$FROM_VERSION")

        TO_VERSION=$(echo "$version_response" | jq -r '.latest // empty')
        if [[ -z "$TO_VERSION" ]]; then
            error "Could not determine latest version for ${COMPONENT}"
            exit 1
        fi

        local upgrade_available
        upgrade_available=$(echo "$version_response" | jq -r '.upgrade_available // false')
        if [[ "$upgrade_available" != "true" ]]; then
            success "${COMPONENT} is already up to date (${FROM_VERSION})"
            exit 0
        fi

        info "Latest ${COMPONENT} version: ${TO_VERSION}"
    else
        info "Target version: ${TO_VERSION}"

        # Validate target is newer than current
        if compare_versions "$TO_VERSION" "$FROM_VERSION"; then
            success "${COMPONENT} is already at or above ${TO_VERSION}"
            exit 0
        fi
        # compare_versions returns 2 if TO > FROM, which is what we want
    fi

    echo ""

    # Step 5: Fetch manifest and identify migrations
    info "Fetching migration manifest..."
    local manifest
    manifest=$(fetch_manifest "$COMPONENT" "$TO_VERSION")

    local migrations
    migrations=$(filter_migrations "$manifest" "$FROM_VERSION" "$TO_VERSION")

    local migration_count
    migration_count=$(echo "$migrations" | jq 'length')

    if [[ "$migration_count" -eq 0 ]]; then
        info "No migrations needed between ${FROM_VERSION} and ${TO_VERSION}"
    else
        echo -e "Migrations to apply (${BOLD}${migration_count}${NC} version jumps require changes):"
        echo ""

        local i=1
        echo "$migrations" | jq -r '.[] | "  \(.from) -> \(.to): \(.description)"' | while read -r line; do
            echo -e "  ${CYAN}${i}.${NC} v${line}"
            ((i++)) || true
        done

        echo ""
    fi

    # Check-only mode stops here
    if [[ "$CHECK_ONLY" == "true" ]]; then
        if [[ "$migration_count" -gt 0 ]]; then
            echo "Run without --check to apply these migrations."
        fi
        exit 0
    fi

    # Step 6: Apply migrations
    if [[ "$migration_count" -gt 0 ]]; then
        if ! confirm "Proceed with migrations?"; then
            info "Upgrade cancelled."
            exit 0
        fi

        echo ""

        # Create temp directory for downloaded scripts
        local tmp_dir
        tmp_dir=$(mktemp -d)
        trap "rm -rf '$tmp_dir'" EXIT

        # Download and verify all scripts first
        info "Downloading and verifying migration scripts..."
        local idx=0
        local script_paths=()
        local script_froms=()

        while IFS= read -r migration; do
            local script_name from_ver sha256
            script_name=$(echo "$migration" | jq -r '.script')
            from_ver=$(echo "$migration" | jq -r '.from')
            sha256=$(echo "$migration" | jq -r '.sha256')

            local dest="${tmp_dir}/${script_name}"
            if ! download_migration "$COMPONENT" "$TO_VERSION" "$script_name" "$sha256" "$dest"; then
                error "Aborting upgrade - checksum verification failed"
                exit 1
            fi

            script_paths+=("$dest")
            script_froms+=("$from_ver")
            ((idx++)) || true
        done < <(echo "$migrations" | jq -c '.[]')

        success "All scripts verified"
        echo ""

        # Execute scripts in sequence
        for ((i = 0; i < ${#script_paths[@]}; i++)); do
            local script="${script_paths[$i]}"
            local script_basename
            script_basename=$(basename "$script")
            local from_v="${script_froms[$i]}"

            echo -e "${BOLD}Running migration ${script_basename}...${NC}"

            # Execute with POLIS_BASE set
            if ! POLIS_BASE="$SITE_DIR" bash "$script"; then
                echo ""
                error "Migration failed: ${script_basename}"

                # Determine next version for recovery
                if ((i + 1 < ${#script_froms[@]})); then
                    local next_from="${script_froms[$((i + 1))]}"
                    echo "  To resume after fixing the issue:" >&2
                    echo "    polis-upgrade --from ${next_from} --to ${TO_VERSION}" >&2
                else
                    echo "  This was the last migration. Fix the issue and re-run:" >&2
                    echo "    polis-upgrade --from ${from_v} --to ${TO_VERSION}" >&2
                fi
                exit 1
            fi

            echo ""
        done

        success "All migrations complete."
        echo ""
    fi

    # Step 7: Offer to download updated binary
    local binary_name="polis"
    if [[ "$COMPONENT" == "tui" ]]; then
        binary_name="polis-tui"
    fi

    local install_path="${POLIS_PATH:-${SITE_DIR}/${binary_name}}"
    local download_url="${GITHUB_RAW_BASE}/v${TO_VERSION}/cli/bin/${binary_name}"

    echo -e "Download updated ${COMPONENT} (v${TO_VERSION}) to ${DIM}${install_path}${NC}?"
    if confirm "Proceed?"; then
        local tmp_binary
        tmp_binary=$(mktemp)

        if ! curl -s --max-time 60 -L -o "$tmp_binary" "$download_url"; then
            error "Failed to download ${binary_name} v${TO_VERSION}"
            rm -f "$tmp_binary"
            exit 1
        fi

        # Verify it's a valid script
        if ! head -1 "$tmp_binary" | grep -q '^#!/'; then
            error "Downloaded file is not a valid script"
            rm -f "$tmp_binary"
            exit 1
        fi

        # Check if we can write to the install path
        if [[ -f "$install_path" ]] && [[ ! -w "$install_path" ]]; then
            warn "Cannot write to ${install_path} (permission denied)"
            echo "  Try: sudo cp ${tmp_binary} ${install_path} && sudo chmod +x ${install_path}" >&2
            rm -f "$tmp_binary"
            exit 1
        fi

        cp "$tmp_binary" "$install_path"
        chmod +x "$install_path"
        rm -f "$tmp_binary"

        success "Downloaded ${binary_name} v${TO_VERSION}"
    fi

    echo ""
    success "Upgrade complete!"
}

main "$@"
